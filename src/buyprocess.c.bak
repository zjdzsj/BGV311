/******************************************************************************************
*  Copyright (c) 2013,  R&D Department
*  All rights reserved 
*
*  FileName：   	buyprocess.c
*  Author：     	Roger
*  Date：  			2010-3-8 20:10
*  Revised Date：  	
*  Main Function：  this file contains all the functions used in I2C communications.
*  Version:			V1.0
*  Note： 			 			
*********************************************************************************************/
#pragma sfr
#pragma di
#pragma ei
#pragma NOP
#pragma HALT
#pragma STOP

#define _BUY_PROCESS_DEFINE_
#include "include.h"



//variables statement
/******************************************************************************************/
const uchar SELFKEY[16]={0x84,0x71,0xb5,0xbc,0xde,0x4d,0x4b,0xbe,
				0xfb,0x1d,0x45,0xa8,0x56,0xef,0x85,0xc8};


//初始化参数 11
//初始化参数 11
const uchar INIT_PRICE_TABLE[]={
	//费率电价信息	8	 11
	0x00,0x00,		//费率电价1  低字节在前 高字节在后 2字节 11
	0x00,0x00,		//费率电价2  2字节 11
	0x00,0x00,	    //费率电价3  2字节 11
	0x00,0x00,		//费率电价4  2字节 11
	0x00,0x00,		//费率电价5  2字节 11
	0x00,0x00,		//费率电价6  2字节 11	
	0x00,0x00,0x00,	//保留3字节 	 11							
	//0x00			//16	
};

const uchar INIT_PASSWORD_TABLE[]={
	0x02,               //通讯密码 4 11	
	0x00,0x00,0x00,
	//0x02		        //校验码	   16
};

const uchar INIT_YEAR_ZONE_TABLE[]={
	0x01,		//年时区数 11
	0x01,		//时段表数 11
	0x08,		//日时段表数 11
	0x01,0x01,0x01,		//第1年时区 11
	0x01,0x01,0x01,			//第2年时区 11
	0x01,0x01,0x01,			//第3年时区 11
	0x01,0x01,0x01,			//第4年时区 11
	//0x10		    //校验和	 11
};

const uchar INIT_TARIFF_TBL1[]={
	//第1时段表 费率时段表 12 13 14 
	0x04,0x00,0x00,		//第1时段表 11
	0x04,0x00,0x08,		//第2时段表 11
	0x04,0x00,0x08,		//第3时段表 11
	0x04,0x00,0x08,	    //第4时段表 11
	0x04,0x00,0x08,		//第5时段表	11
	0x04,0x00,0x08,		//第6时段表 11
	0x04,0x00,0x08,		//第7时段表 11
	0x04,0x00,0x08,		//第8时段表	11  
	0x04,0x00,0x08,		//第9时段表 11
	0x04,0x00,0x08,		//第10时段表 11
	0x04,0x00,0x08,	    //第11时段表 11
	0x04,0x00,0x08,		//第12时段表 11
	0x04,0x00,0x08,		//第13时段表 11
	0x04,0x00,0x08,		//第14时段表 11	  					
	//unsigned char Checksum10;		// 43	
};


const uchar INIT_LADDER_VALUE_TBL[]={
	//阶梯值信息	36
	0x00,0x00,		//阶梯值1  2字节 11
	0x00,0x00,		//阶梯值2  2字节 11
	0x00,0x00,		//阶梯值3  2字节 11
	0x00,0x00,		//阶梯值4  2字节 11
	0x00,0x00,		//阶梯值5  2字节 11	
	0x00,0x00,		//阶梯值6  2字节 11
	0x00,0x00,		//阶梯值7  2字节 11								
	//unsigned char Checksum6;		//11
};

const uchar INIT_LADDER_PRICE_TBL[]={
	//阶梯电价信息	37
	0x00,0x00,		//0x50,0x14, 默认5200 0.52 阶梯电价1  2字节 11
	0x00,0x00,		//阶梯电价2  2字节 11
	0x00,0x00,		//阶梯电价3  2字节 11
	0x00,0x00,	    //阶梯电价4  2字节 11
	0x00,0x00,		//阶梯电价5  2字节 11
	0x00,0x00,		//阶梯电价6  2字节	11	
	0x00,0x00,		//阶梯电价6  2字节	11
	0x00,0x00,		//阶梯电价6  2字节	11							
	//unsigned char Checksum7;		//12+1=13
};

//初始化参数 11
const char INIT_SOFTWARE_VERSION[8]={	' ',' ',
										VERSION_UPDATE_2+0X30,
										VERSION_UPDATE_1+0X30,
										'.',
										VERSION_HEAD_2+0x30,
										VERSION_HEAD_1+0x30,
										'V'																																		
										};  
/******************************************************************************************/

#ifdef PRE_PAID_ENABLE
//function statement
/******************************************************************************************/
static void StoreBuyHistroy ( uchar* buf );

#if(PROTOCOL_ADD_ORDERS==1)
	static uchar OneBCDToHex( uchar p );
	static uchar CaculateLessDays ( uchar* pbuf1, uchar* pbuf2 );
	static uchar CheckOrdersValid ( uchar *pbuf, uchar len );
	static void StoreOrdersHistroy ( uchar* buf );
#endif

/******************************************************************************************/

#endif

#ifdef PRE_PAID_ENABLE
/*
*****************************************************************************************
* fuction name: ProcessUserBuyQuan
*
* Description : this function process user buy
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
uchar ProcessUserBuyQuan ( uchar *pbuf, uchar mode, uchar buyMode )
{           
    uchar i,eFlag,usedFlag;
    uint16 buycnt;
    uint32 buyQuan,tempBalance,tempCrossZero,temp32;
#if(PROTOCOL_ADD_ORDERS==1)
	uchar ret;
#endif       
    eFlag = 0;      //默认不更新EEPRM购电记录 11
    usedFlag = 0;
                     
    //获取购电次数与购电金额 11
    if ( buyMode == 1 )		//卡购电 11
    {
    	buycnt = ((uint16)pbuf[17]<<8) + pbuf[16];
    	buyQuan = ((uint32)pbuf[15]<<24) + ((uint32)pbuf[14]<<16) + ((uint32)pbuf[13]<<8)+ pbuf[12];
    
    #if(IC_CARD_MODE==AT24_CARD)
    	CardI2CRead ( CARD_ADDR, 0x90, (uchar*)&usedFlag, 1 );
    #endif
    
    #if(IC_CARD_MODE==RF_CARD)
    	if ( ReadBlockData ( 05, (uchar*)g_buf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	    usedFlag = g_buf[0];
	#endif	
    }
    else
    {
    	buycnt = (uint16)BCDToHex( &pbuf[16], 2 );
    	buyQuan = BCDToHex( &pbuf[12], 4 )*100; 	
    }  
    
    if ( buyQuan > 3000000000 )
    {
        return COMM_OVER_BUY_QUAN_ERR;    
    } 
    
    //判断订单号是否符合 11
#if(PROTOCOL_ADD_ORDERS==1)
	if ( buyMode > 1 )
	{
		ret = CheckOrdersValid ( pbuf, buyMode );	
		if ( ret > 0 )
			return ret;
		//订单是合理的 进行购电次数赋值操作 11
		buycnt = g_buyPara.BuyCount + 1;			
	}
#endif
                 
    //用户卡子类型处理 11
    if ( (mode == NORMAL_MODE) ||     //正常售电 11
            ( mode == BUY_RETURN_MODE )  )    //售电退费 11    
    {
        if ( g_buyPara.Status == BACK_MONEY_STATUS )    //销户退费模式处理 11
        {
            return HAVE_IN_RETURN_MODE;   
        }
        
        //售电退费 购电次数必须大于1 11
        if ( mode == BUY_RETURN_MODE )
        {
            if ( buycnt < 1 )    
                return COMM_BUY_CNT_ERR; 
        }    
        
        //购电次数为0 为开户卡 11
        if ( buycnt == 0 )
        {
            //购电金额必须为 0 
            if ( buyQuan > 0 )
                return OPEN_CARD_INFO_ERR;                        
        }
        
        //购电次数判断:只有两种情况是正常情况： 11
        //1)购电次数相同，说明是补卡 或重新插卡 11
        //2)表内购电次数比卡上购电次数少1次 正常售电 11
        if ( (buycnt != g_buyPara.BuyCount) &&
                ((buycnt-1) != g_buyPara.BuyCount) )
            return COMM_BUY_CNT_ERR;
            
        //表计卡户判断：卡上购电次数为0,表计购电次数也为0 或者 11
        //卡上购电次数为1，表计购电次数为0 11              
        if ( (buycnt<2) && (g_buyPara.BuyCount==0) )
        {            
            //用户编号绑定 11
            for ( i=0; i<6; i++ )       
                g_addr.CardNum[i] = pbuf[6+i]; 
                
            g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
	        StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
		        (uchar*)&g_addr.Zone,Meter_Addr_Len );               
        }
                        
        //正常购电 11
        //只是 开户更新参数 11   
        if ( (g_buyPara.BuyCount == 0) && (buycnt==0) &&
        			(usedFlag==0) )
        {             
            tempCrossZero = g_energy.Overdraft;    
            tempBalance = g_energy.Balance;                 
        }   
        else if ( (((buycnt-1) == g_buyPara.BuyCount)) &&
        			(usedFlag==0) )     //正常购电 11
        {            
            //新增2019/01/08 11
            temp32 = g_energy.Balance+buyQuan;
            if ( temp32 < buyQuan )
            {
            	return COMM_OVERMAX_ERR;	
            }
            
            //判断囤积金额 11
//            if ( (buycnt==1) )
//            {
//            	temp32 = g_energy.Balance+buyQuan-g_energy.PrePaid;
//            	if ( temp32 >= 
//	                (((uint32)g_para.MaximBalance)*10000) ) //4位小数 11
//	            {
//	            	return COMM_OVERLIMIT_ERR;       
//	            } 
//            }
//            else
//            {
//            	if ( (g_energy.Balance+buyQuan) >= 
//	                (((uint32)g_para.MaximBalance)*10000) ) //4位小数 11
//	            {
//	            	return COMM_OVERLIMIT_ERR;       
//	            }  	
//            }
            
                        
            
            if ( mode == NORMAL_MODE )    //正常购电 11
            {                                                       
                temp32 = buyQuan;                
                //处理预置金额 11
                if ( buycnt == 1 )
                {
                	if ( g_para.CurrentRatio == 65535 )		//为了兼容老系统 系统扣除预置金额 11
                	{
                		//购电金额处理 包含过零金额处理 11
		            	if ( g_energy.Overdraft > temp32 )
		            	{
		            		tempCrossZero = g_energy.Overdraft-temp32;	
		            		tempBalance = 0;	
		            	}
		            	else
		            	{
		                	tempBalance = g_energy.Balance+(temp32-g_energy.Overdraft);
		                	tempCrossZero = 0;
		                }	
                	}
                	else
                	{
                		temp32 = g_energy.PrePaid; 
	                	if ( temp32 > buyQuan )		//购电金额小于预置金额 11
	                	{
	                		//return COMM_FIRST_BUY_LESS_ERR;	
	                		//计算应剩余金额 11
	                		if ( g_energy.Balance > 0 )
	                		{
	                			temp32 = g_energy.PrePaid - g_energy.Balance;	//已使用金额 11                				
	                			if ( buyQuan > temp32 )
	                			{
	                				tempBalance = buyQuan-temp32;
	                				tempCrossZero = 0;		
	                			}
	                			else
	                			{
	                				tempCrossZero = temp32 - buyQuan;
	                				tempBalance = 0;	
	                			}
	                		}
	                		else
	                		{
	                			temp32 = g_energy.PrePaid + g_energy.Overdraft;	//已使用金额 11	
	                			
	                			tempCrossZero = temp32 - buyQuan;
	                			tempBalance = 0;
	                		}	                		                		
	                	}
	                	else
	                	{
	                		temp32 = buyQuan - temp32;	//
	                		
	                		//购电金额处理 包含过零金额处理 11
			            	if ( g_energy.Overdraft > temp32 )
			            	{
			            		tempCrossZero = g_energy.Overdraft-temp32;	
			            		tempBalance = 0;	
			            	}
			            	else
			            	{
			                	tempBalance = g_energy.Balance+(temp32-g_energy.Overdraft);
			                	tempCrossZero = 0;
			                }		
	                	} 	
                	}
                	               			
                		
                }
                else
                {
                	//购电金额处理 包含过零金额处理 11
	            	if ( g_energy.Overdraft > temp32 )
	            	{
	            		tempCrossZero = g_energy.Overdraft-temp32;	
	            		tempBalance = 0;	
	            	}
	            	else
	            	{
	                	tempBalance = g_energy.Balance+(temp32-g_energy.Overdraft);
	                	tempCrossZero = 0;
	                }	
                }	
                                                                                         
            }
            else if ( mode == BUY_RETURN_MODE )   //购电退费 11
            {           	
                temp32 = buyQuan;
                
                //购电金额处理 包含过零金额处理 11
            	if ( g_energy.Balance >= temp32 )
            	{
            		tempBalance = g_energy.Balance-temp32;
                	tempCrossZero = 0;               		
            	}
            	else
            	{
                	if ( g_energy.Balance > 0 )
                	{
                		tempCrossZero = temp32-g_energy.Balance;		
                	}
                	else
                	{
                		tempCrossZero = g_energy.Overdraft + temp32-g_energy.Balance;	
                	}
                	tempBalance = 0;
                }                                  
            }
                                  
            eFlag = 1;      //需要更新11 
                                                                  
        }        
        else        //购电次数相同 只更新返写区数据 11
        {
            tempCrossZero = g_energy.Overdraft;    
            tempBalance = g_energy.Balance;
            
        }         
        //返写区处理 统一处理 见下面 11
                
    }
    else if ( mode == CANCEL_RETURN_MODE )        //销户退费 11
    {
        if ( g_buyPara.Status != BACK_MONEY_STATUS )		//判断退费状态 11
        {
        	//购电次数必须相同 11
	        if ( buycnt != g_buyPara.BuyCount )
	            return COMM_BUY_CNT_ERR;
	            
	        //需要返写剩余金额 即退费金额 和透支金额 11    
	        buyQuan = g_energy.Balance;
	        
	        tempCrossZero = g_energy.Overdraft;    
	        tempBalance = g_energy.Balance;
	        
	        eFlag = 1;	
        }
        
    }
    
    //卡购电 先更新卡返回区数据 11   
    if ( buyMode == 1 )
    {
    	//先进行返写操作   11     
	    //到这，更新使用标志和返写区 11
	    g_buf[0] = 0xa6;
	    //购电次数 11
	    g_buf[1] = (uchar)((buycnt>>8)&0xff);
	    g_buf[2] = (uchar)((buycnt>>0)&0xff);
	    //卡号后2位数 11
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x10]; 
	    g_buf[3] = pbuf[7];
	    g_buf[4] = pbuf[8]; 
	    //本次购电金额  11
	    g_buf[5] = (uchar)((buyQuan>>24)&0xff);
	    g_buf[6] = (uchar)((buyQuan>>16)&0xff);   
	    g_buf[7] = (uchar)((buyQuan>>8)&0xff);
	    g_buf[8] = (uchar)((buyQuan>>0)&0xff);
	    //累计用电量 11  
	    g_buf[9] = (uchar)((g_energy.Accumulate>>24)&0xff);
	    g_buf[10] = (uchar)((g_energy.Accumulate>>16)&0xff);   
	    g_buf[11] = (uchar)((g_energy.Accumulate>>8)&0xff);
	    g_buf[12] = (uchar)((g_energy.Accumulate)&0xff);
	    //电表状态 11
	    g_buf[13] = g_errStatus.Byte;
	    g_buf[14] = 0; 
	    for ( i=0; i<14; i++ )
	        g_buf[14] += g_buf[i];
	    g_buf[15] = 0x3a; 
	    Encrypt ( g_buf, 0, 16 ); 
	
	#if(IC_CARD_MODE==AT24_CARD)     
	    if ( CardI2CWrite ( CARD_ADDR, 0x80, (uchar*)&g_buf[0], 16 ) != 1 )
	    {
	        return WRITE_BACK_ERR;         
	    }
	#endif
	
	#if(IC_CARD_MODE==RF_CARD)     
	    if ( WriteBlockData ( 4, (uchar*)&g_buf[0] ) == FALSE ) 
	    {
	    	return WRITE_BACK_ERR;	
	    }	
	#endif
	    
	    //卡使用标识 11
	     g_buf[0] = 0x01;
	    //上次插卡操作成功时间 11
	    g_buf[1] = g_date.year;
	    g_buf[2] = g_date.month;    
	    g_buf[3] = g_date.day;
	    g_buf[4] = g_date.hour;
	    g_buf[5] = g_date.min;
	    g_buf[6] = g_date.sec; 
	    for ( i=7; i<15; i++ )		//added by Roger 2015/07/24
	        g_buf[i] = 0;
	#if(IC_CARD_MODE==AT24_CARD) 
	    if ( CardI2CWrite ( CARD_ADDR, 0x90, (uchar*)&g_buf[0], 7 ) != 1 )
	    {
	        return WRITE_BACK_ERR;  
	    }
	#endif 
	
	#if(IC_CARD_MODE==RF_CARD)     
	    if ( WriteBlockData ( 5, (uchar*)&g_buf[0] ) == FALSE ) 
	    {
	    	return WRITE_BACK_ERR;	
	    }	
	#endif
	   
	    //返写参数区 11
	    g_buf[0] = 0xa6;
	    //限电功率 11
	    g_buf[1] = (uchar)((g_para.LimitPower>>8)&0xff);
	    g_buf[2] = (uchar)((g_para.LimitPower>>0)&0xff);
	    //囤积金额限值 11
	    g_buf[3] = (uchar)((g_para.MaximBalance>>8)&0xff);
	    g_buf[4] = (uchar)((g_para.MaximBalance>>0)&0xff);
	    //透支金额限值 2位小数 11
	    temp32 = g_para.CreditLimit/100;
	    g_buf[5] = (uchar)((temp32>>8)&0xff);
	    g_buf[6] = (uchar)((temp32>>0)&0xff);
	    //电表互感比 11  
	    g_buf[7] = (uchar)((g_para.CurrentRatio>>8)&0xff);
	    g_buf[8] = (uchar)((g_para.CurrentRatio)&0xff);
	    //电价 11
	    g_buf[9] = (uchar)((g_price>>24)&0xff);
	    g_buf[10] = (uchar)((g_price>>16)&0xff);   
	    g_buf[11] = (uchar)((g_price>>8)&0xff);
	    g_buf[12] = (uchar)((g_price>>0)&0xff);
	    
	    g_buf[13] = 0;
	    g_buf[14] = 0;
	    for ( i=0; i<14; i++ )
	        g_buf[14] += g_buf[i];
	    g_buf[15] = 0x3a; 
	    Encrypt ( g_buf, 0, 16 ); 
	
	#if(IC_CARD_MODE==AT24_CARD)       
	    if ( CardI2CWrite ( CARD_ADDR, 0xa0, (uchar*)&g_buf[0], 16 ) != 1 )
	    {
	        return WRITE_BACK_ERR;         
	    }	
	#endif
	
	#if(IC_CARD_MODE==RF_CARD)     
	    if ( WriteBlockData ( 6, (uchar*)&g_buf[0] ) == FALSE ) 
	    {
	    	return WRITE_BACK_ERR;	
	    }	
	#endif
		
    }
      
    //更新购电记录 EEPROM 11
    if ( eFlag == 1 )
    {               
        //本次购电金额  最近1次充退费金额 销户退费金额 11
      	temp32 = buyQuan/100;    
        temp32 = Hex32ToBCD( temp32 );   
        g_buf[0] = (uchar)((temp32>>0)&0xff);
        g_buf[1] = (uchar)((temp32>>8)&0xff);
        g_buf[2] = (uchar)((temp32>>16)&0xff); 
        g_buf[3] = (uchar)((temp32>>24)&0xff);   
        if ( mode == BUY_RETURN_MODE )   //购电退费 11
        {
            //如果是退费 保存退费金额记录 11
            EEPROM_NOWP();
    	    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1_ReturnQuan), 
    		    &g_buf[0], 4, 1  );
		    EEPROM_WP();
            
            g_buf[3] =  0x80;       //最高位置1 11   
        }           
        //购电次数 2 11
    	temp32 = Hex16ToBCD( buycnt );
        g_buf[4] = (uchar)(temp32 & 0xff);
        g_buf[5] = (uchar)((temp32>>8) & 0xff);
        
        //购电前剩余金额 11
        if ( buycnt == 1 )  //第一次购电 11
        {
            temp32 = 0;
        }
        else
            temp32 = g_energy.Balance/100;
        temp32 = Hex32ToBCD( temp32 ); 
        g_buf[6] = (uchar)((temp32>>0)&0xff);
        g_buf[7] = (uchar)((temp32>>8)&0xff);
        g_buf[8] = (uchar)((temp32>>16)&0xff); 
        g_buf[9] = (uchar)((temp32>>24)&0xff);  
        
        //购电后剩余金额 11
        temp32 = tempBalance/100;
        temp32 = Hex32ToBCD( temp32 );  
        g_buf[10] = (uchar)((temp32>>0)&0xff);
        g_buf[11] = (uchar)((temp32>>8)&0xff);
        g_buf[12] = (uchar)((temp32>>16)&0xff); 
        g_buf[13] = (uchar)((temp32>>24)&0xff);
        
        //购电后累计购电金额 11
        I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1_BuyQuan), 
 					&g_buf[20], 18, 1  ) ;
        temp32 = BCDToHex( &g_buf[34], 4 ); 
        if ( mode == BUY_RETURN_MODE )   //购电退费 11
            temp32 -= buyQuan/100;       
        else
        {
            temp32 += buyQuan/100;                           
        }
        temp32 = Hex32ToBCD( temp32 );      
        g_buf[14] = (uchar)((temp32>>0)&0xff);
        g_buf[15] = (uchar)((temp32>>8)&0xff);
        g_buf[16] = (uchar)((temp32>>16)&0xff); 
        g_buf[17] = (uchar)((temp32>>24)&0xff);
        
        //保存本次购电记录 11
        StoreBuyHistroy ( g_buf );
		       		
		g_energy.Balance = tempBalance;
        g_energy.Overdraft = tempCrossZero;
        
      	g_buyPara.BuyQuan = buyQuan/100;
        g_buyPara.BuyCount++;       //购电次数累计 11
               		
        //更新EEPROM 11
        g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
        StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
    			(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len );    	
    	
    	SaveEnergy ( NORMAL_SAVE ); 
    	
    	//保存订单号 11
    #if(PROTOCOL_ADD_ORDERS==1)
    	if ( buyMode > 1 )	
    	{
    		StoreOrdersHistroy ( pbuf+buyMode-8 );	
    	}
    #endif	
    	
    }
    
    //销户返写成功后 切换状态 11
    if ( mode == CANCEL_RETURN_MODE )
    {
        g_buyPara.Alarm1 = 0;
        g_buyPara.Alarm2 = 0;	
                
        g_buyPara.Status = BACK_MONEY_STATUS;  
        //退费状态后 表计跳闸 11      
        g_relayFlag.Bit.RelayOn = 1;
        g_meterStatus3.Bit.StatusMeter = 1;		//退费状态 11
        
        //更新EEPROM 11
        g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
        StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
    			(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len );
    }
                      
    
#ifdef TARIFF_ENABLE        
    g_meterFlag.Bit.TariffProcess = 1;
#endif 
                    
    
    
    if ( g_energy.Balance > 0 )
    {   	
    	//报警跳闸重置 11
    	g_relayFlag.Bit.RelayAlarmHappened = 0;
    	g_relayFlag.Bit.BalanceZeroHappened = 0;
    	g_relayFlag.Bit.BalanceZero5MinFlg = 0;
    	g_relayFlag.Bit.RelayAlarmOn = 0;
    	
    	ProcessRelayStatus ( );
    	ProcessRelay ( );
    }
        
    return 0;
      
}

/*
*****************************************************************************************
* fuction name: CheckOrdersValid
*
* Description : this function process user buy
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
#if(PROTOCOL_ADD_ORDERS==1)
static uchar CheckOrdersValid ( uchar *pbuf, uchar len )
{           
    
    uchar i,j,eFlag,usedFlag,diff;
    uint32 order1,order2,tempOrder1,tempOrder2;
    uint16 order3,tempOrder3;
    uchar *ptmepBuf;
        
    usedFlag = 0;
      
    //获取购电订单号 11
    ptmepBuf = pbuf + len -8;
    for( i=0; i<8; i++ )
   	{
   		if ( CheckBCD(ptmepBuf[i]) == 1 )
   			break;
   	}
   	if ( i < 8 )
   		return COMM_ORDER_NUM_ERR;       	 
    //yymmdd
    order1 = (((uint32)ptmepBuf[7])<<16) + 
    			(((uint32)ptmepBuf[6])<<8) + 
    			((uint32)ptmepBuf[5]);
    //hhmmss
    order2 = (((uint32)ptmepBuf[4])<<16) + 
    			(((uint32)ptmepBuf[3])<<8) + 
    			((uint32)ptmepBuf[2]);
    //counter
    order3 =  (((uint16)ptmepBuf[1])<<8) + 
    			((uint16)ptmepBuf[0]);
    
    //表内存储订单号比对 11
    eFlag = 0;		//默认表内存储数据正确 11

    for( i=0; i<10; i++ )
    {
    	I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1_Order)+8*i,
				(uchar*)&g_buf[0], 8, 1  );	
    	
    	for( j=0; j<8; j++ )
	   	{
	   		if ( CheckBCD(g_buf[j]) == 1 )
	   		{	   			
	   			break;
	   		}	   		
	   	}
	   	if ( j < 8 )
	   	{
	   		eFlag++;
	   		continue;
	   	}
	   	
    	//yymmdd
	    tempOrder1 = (((uint32)g_buf[7])<<16) + 
	    			(((uint32)g_buf[6])<<8) + 
	    			(((uint32)g_buf[5]));
	    //hhmmss
	    tempOrder2 = (((uint32)g_buf[4])<<16) + 
	    			(((uint32)g_buf[3])<<8) + 
	    			((uint32)g_buf[2]);
	    //counter
	    tempOrder3 = (((uint16)g_buf[1])<<8) + 
	    			((uint16)g_buf[0]);
	    			
    	//与最近1次订单号比较时间 提示错误 11
    	if ( i == 0 )
    	{
    		if ( (order1 < tempOrder1) ||
    			((order1==tempOrder1)&&(order2<tempOrder2)) )
    		{
    			diff = CaculateLessDays ( ptmepBuf, g_buf );
    			if ( diff > 30 )	
    				return COMM_ORDER_OVER_ERR;
    		}	
    	}
    	    	   		   		   		   	
	   	//判断是否相等 11
	   	if ( (order1 == tempOrder1) &&
	   			( order2 == tempOrder2 ) &&
	   			( order3 == tempOrder3 ) )
	   	{
	   		usedFlag = 1;
	   		break;	
	   	}	   			  	    	
    }
    if ( eFlag > 0 )  
    {
    	
    } 
                   
    //到这说明订单号可以用 下面进行数据充值 11
    if ( usedFlag == 0 )                 
    	return 0;
    else
    	return COMM_ORDER_USED_ERR;
      
}
#endif
/*
*****************************************************************************************
* fuction name: CaculateLessDays
*
* Description : 计算比存储的时间小多少天
*
* Arguments   : uchar* buf, uchar len
*		
* returns     : uchar checksum
*
* Notes     :	 
******************************************************************************************
*/
#if(PROTOCOL_ADD_4_SERIALS==1)
static uchar CaculateLessDays ( uchar* pbuf1, uchar* pbuf2 )
{
	uchar diff;
	
	diff = 0;
	//pbuf2是存储时间 pbuf1为当前时间 11
	if ( pbuf2[7] >= pbuf1[7] )		//year
	{
		diff = OneBCDToHex( pbuf2[7] ) - OneBCDToHex( pbuf1[7] );
		if ( diff >= 2 )
			return 0xff;
		else if ( diff == 1 )		//跨年 11
		{
			if ( pbuf1[6] >= pbuf2[6] )	//month
				return 0xff;
			
			diff = 12 + OneBCDToHex( pbuf1[6] ) - OneBCDToHex( pbuf2[6] );
			if ( diff >= 2 )
				return 0xff;
			
			diff = 31 + OneBCDToHex( pbuf1[5] ) - OneBCDToHex( pbuf2[5] );	
		}
		else //同年 11
		{					
			if ( pbuf2[6] >= pbuf1[6] )	//month
			{
				diff = OneBCDToHex( pbuf1[6] ) - OneBCDToHex( pbuf2[6] );
				if ( diff >= 2 )		//超过1个月 11
					return 0xff;
				else if ( diff == 1 )		//跨月 11
				{
					diff = 30 + OneBCDToHex( pbuf1[5] ) - OneBCDToHex( pbuf2[5] );	
				}
				else		//同月 11
				{														
					if ( pbuf2[5] > pbuf1[5] )	//day
					{
						diff = pbuf2[5] - pbuf1[5];
					}	
				}
			}	
			
		}			
			
	}	
	
	
	return diff;
}
#endif
/*
*****************************************************************************************
* fuction name: OneBCDToHex
*
* Description : This function visualize the request item according to the diffrent condition.
*
* Arguments   : none
*
* returns     : none
*
* Notes     :
******************************************************************************************
*/
#if(PROTOCOL_ADD_ORDERS==1)
static uchar OneBCDToHex( uchar p )
{
    uchar ret; 
   
    ret = (p>>4)*10+(p&0x0f);		
                                
    return( ret );
    
}
#endif

/*
*****************************************************************************************
* fuction name: StoreOrdersHistroy
*
* Description : 存储最近10次订单号记录 
*
* Arguments   : uchar* buf, uchar len
*		
* returns     : uchar checksum
*
* Notes     :	 
******************************************************************************************
*/
#if(PROTOCOL_ADD_ORDERS==1)
static void StoreOrdersHistroy ( uchar* buf )
{
    uchar i;
    uchar temp[8];
    
   	//转存近9次订单数据 11
    for ( i=0; i<9; i++ )
    {
        I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last9_Order)-8*i, 
				&temp[0], 8, 1  ) ;
        
        EEPROM_NOWP();
    	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last10_Order)-8*i, 
    		    &temp[0], 8, 1  );
		EEPROM_WP();
		
		Delay1MsTime ( 2 );
		
		FeedWatchdog ( );							
    }
    
    //存储最近1次订单记录数据 11    
    EEPROM_NOWP();
	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1_Order), 
		    &buf[0], 8, 1  );
	EEPROM_WP();
	FeedWatchdog ( );
		
    return;
}
#endif
/*
*****************************************************************************************
* fuction name: StoreBuyHistroy
*
* Description : 存储购电记录 
*
* Arguments   : uchar* buf, uchar len
*		
* returns     : uchar checksum
*
* Notes     :	 
******************************************************************************************
*/
static void StoreBuyHistroy ( uchar* buf )
{
    uchar i;
    uchar temp[18];
    
   	//转存近9次购电数据 11
    for ( i=0; i<9; i++ )
    {
        I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last9_BuyQuan)-18*i, 
				&temp[0], 18, 1  ) ;
        
        EEPROM_NOWP();
    	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last10_BuyQuan)-18*i, 
    		    &temp[0], 18, 1  );
		EEPROM_WP();
		
		Delay1MsTime ( 5 );
		
		FeedWatchdog ( );							
    }
    
    //存储最近1次购电记录数据 11    
    EEPROM_NOWP();
	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1_BuyQuan), 
		    &buf[0], 18, 1  );
	EEPROM_WP();
	FeedWatchdog ( );
		
    return;
}

#endif
/*
*****************************************************************************************
* fuction name: Decrypt
*
* Description : this function decrypt the output data in IC card.
*
* Arguments   : 1)uchar *buf : the data need to decrypt
*		2)uchar pos: the location in IC card
*		3)uchar len: the lenght of data need to decrypt
*		4)uchar fixedChar: the key data
*
* returns     : null 
*
* Notes       :
******************************************************************************************
*/

void Decrypt ( uchar *buf, uchar pos, uchar len, uchar fixedChar )
{
    uchar randnum;
    uchar i;
    uchar addr;
    
    addr = (pos + POSKEY)&0x0f;
    randnum = (buf[0] - SELFKEY[addr])^fixedChar;
    buf[0] = fixedChar;
        
    pos++;      
    for ( i=1; i<len; i++ )
    {
        addr = (pos + POSKEY)&0x0f;
        buf[i] -= SELFKEY[addr]; 
        buf[i] ^= randnum;  
        pos++;         
    }
    
    return;
}
/*
*****************************************************************************************
* fuction name: Encrypt
*
* Description : this function encrypt the output data in IC card.
*
* Arguments   : 1)uchar *buf : the data need to encrypt
*		2)uchar pos: the location in IC card
*		3)uchar len: the lenght of data need to encrypt
*
* returns     : null 
*
* Notes       :
******************************************************************************************
*/

void Encrypt ( uchar *buf, uchar pos, uchar len )
{                
    uchar randnum;
    uchar i;
    uchar tmp;
    uchar addr;
    
    //randnum = ((uchar)rand()&0xff); 11
    randnum = SELFKEY[g_randCnt&0x0f];
          
    for ( i=0; i<len; i++ )
    {
        tmp = buf[i] ^ randnum;
        addr = (pos + POSKEY)&0x0f;
        buf[i] = tmp + SELFKEY[addr]; 
        pos++;               
    }
    
    return;
}
				
/*
*****************************************************************************************
* fuction name: ClearAllData
*
* Description : this function process clear all data in meter
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
void ClearAllData ( uint32 preBuy, uint16 price )
{        
    uchar *pchar;
    uchar i,len,len1;
    uint32 tempL;
    
    //清零记录 11
	I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,TotalMeterClearCnt), 
 			&g_buf[0], 3, 1  ) ;
  	tempL = BCDToHex( &g_buf[0], 3 );
  	tempL++;
  	tempL = Hex32ToBCD( tempL );
	g_buf[0] = (uchar)tempL&0xff;
	g_buf[1] = (uchar)(tempL>>8)&0xff;
	g_buf[2] = (uchar)(tempL>>16)&0xff;			
	EEPROM_NOWP();
	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,TotalMeterClearCnt), 
 			&g_buf[0], 3, 1  ) ;
	EEPROM_WP();
		
	for ( i=0; i<9; i++ )
	{
		I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last9MeterClear)-18*i, 
				&g_buf[0], 18, 1  ) ;
		
		EEPROM_NOWP();
    	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last10MeterClear)-18*i, 
    		&g_buf[0], 18, 1  );
		EEPROM_WP();
		
		Delay1MsTime ( 5 );
		
		FeedWatchdog ( );
	}
	g_buf[0] = g_date.year;
	g_buf[1] = g_date.month;
	g_buf[2] = g_date.day;
	g_buf[3] = g_date.hour;
	g_buf[4] = g_date.min;
	g_buf[5] = g_date.sec;
	g_buf[6] = 0x78;
	g_buf[7] = 0x56;
	g_buf[8] = 0x34;
	g_buf[9] = 0x12;
	tempL = Hex32ToBCD( g_energy.PosAccumulate );				
	g_buf[10] = (uchar)tempL&0xff;
	g_buf[11] = (uchar)(tempL>>8)&0xff;
	g_buf[12] = (uchar)(tempL>>16)&0xff;			
	g_buf[13] = (uchar)(tempL>>24)&0xff;
	tempL = Hex32ToBCD( g_energy.NegAccumulate );				
	g_buf[14] = (uchar)tempL&0xff;
	g_buf[15] = (uchar)(tempL>>8)&0xff;
	g_buf[16] = (uchar)(tempL>>16)&0xff;			
	g_buf[17] = (uchar)(tempL>>24)&0xff;
	EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1MeterClear), 
    		&g_buf[0], 18, 1  );
	EEPROM_WP();
	Delay1MsTime ( 5 );
	       
    for ( i=0; i<48; i++ )
    { 
        g_buf[i] = 0;
    }
    
    //EEPROM数据清零 11
    //////////////////////////////////////////////////////////////       
    //掉电数据保存区清零 11
    len = (uchar)(offsetof(EEPROM_DATA,PSTART1)&0xff);
    len >>= 4;
    for( i=0; i<len; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //清零记录和校表参数不清零 11
    len = (uchar)((offsetof(EEPROM_DATA,Zone)&0xff)>>4);
    len1 = (uchar)(offsetof(EEPROM_DATA,TotalMeterClearCnt)>>4);
    for( i=len; i<len1; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //
    len = (uchar)(offsetof(EEPROM_DATA,Zone_B)>>4);        
    for( i=len; i<EEPROM_PAGES; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //////////////////////////////////////////////////////////////
    
    //通讯地址不清  11
    pchar = (uchar*)&g_addr.Zone;
    for ( i=0; i<8; i++ )
    { 
        *pchar++ = 0;
    }
    for ( i=0; i<6; i++ )
        if ( ((g_addr.MeterAddr[i]&0x0f) == 0x0f) ||
              ((g_addr.MeterAddr[i]&0xf0) == 0xf0)  )
            break;
    if ( i < 6 )
    {
        for ( i=0; i<8; i++ )
        {
            g_addr.MeterAddr[i] = 0x11; 
        }               
    }
    //表地址保存 11
    FeedWatchdog ( );
	g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
		(uchar*)&g_addr.Zone,Meter_Addr_Len );
    
    
    //可以全部清零 11
    pchar = (uchar*)&g_buyPara.BuyCount;
    for ( i=0; i<16; i++ )
    { 
        *pchar++ = 0;
    }    
    g_errStatus.Byte = 0;             
    //报警金额1 2 11
    g_buyPara.Alarm1 = ALARM1_DEFAULT;
    g_buyPara.Alarm2 = ALARM2_DEFAULT;			    
    //预置金额 11
    g_buyPara.BuyQuan = 0;
    //功率因数限值 11
    g_buyPara.FactorLimit = 1000;
    //功率因数对应功率限值 11
	g_buyPara.FactorPower = 0;
    g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
	FeedWatchdog ( );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
		(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len );
					
    
    //参数预置 11
    g_para.LimitPower = MAX_POWER_LIMIT;
    g_para.MaximBalance = MAX_BALANCE_LIMIT;
    g_para.CreditLimit = CREDIT_LIMIT;
    g_para.CurrentRatio = CURRENT_RATIO;   
    g_para.Price = price;
    g_para.BonusMoneyNum = 1;
    g_para.MeterTpye = 0; //设置本地售电模式 保电解除11
    g_meterStatus3.Bit.KeepRelay = 0; 
    g_meterStatus3.Bit.RelayCmdStatus = 0;
    g_meterStatus3.Bit.StatusMeter = 0;		//退费状态 11
    g_para.Checksum = GetSum ( (uchar*)&g_para.LimitPower, Meter_Para_Len-1 );
	FeedWatchdog ( );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LimitPower),
		(uchar*)&g_para.LimitPower,Meter_Para_Len );
           
    //电量相关 11
    pchar = (uchar*)&g_energy.Accumulate;
    for ( i=0; i<Meter_EQuan_Len; i++ ) 
        *pchar++ = 0;
    g_price = price;
    g_energy.Balance = preBuy;	 
    g_energy.PrePaid = preBuy;   
    SaveEnergy( NORMAL_SAVE );
    
    //密码初始化为02 000000
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_PASSWORD_TABLE); i++ )
    	g_buf[i] = INIT_PASSWORD_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_PASSWORD_TABLE) );
    StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,PASSWORD),
		(uchar*)&g_buf[0],i+1 );
	
	//初始化软件版本号 11
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_SOFTWARE_VERSION); i++ )
    	g_buf[i] = INIT_SOFTWARE_VERSION[i];
    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,SoftVersion), g_buf, 
    			sizeof(INIT_SOFTWARE_VERSION) ,1 );
    EEPROM_WP(); 
			         
#ifdef TARIFF_ENABLE
	//费率电价信息
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_PRICE_TABLE); i++ )
    	g_buf[i] = INIT_PRICE_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_PRICE_TABLE) );
    StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,TariffPrice1),
		(uchar*)&g_buf[0],i+1 );
  		    
	//时区 费率初始化 11
    //年时区数 11
    FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_YEAR_ZONE_TABLE); i++ )
    	g_buf[i] = INIT_YEAR_ZONE_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_YEAR_ZONE_TABLE) );

    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,YearZoneNum), 
                    g_buf, i+1, 1  );
	EEPROM_WP();
    
    
	//第1时段表 费率时段表 12 13 14 
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_TARIFF_TBL1); i++ )
    	g_buf[i] = INIT_TARIFF_TBL1[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_TARIFF_TBL1) );

    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,HHMMNN1), 
                    g_buf, i+1, 1  );
	EEPROM_WP();	
#endif

#ifdef LADDER_ENABLE	
	//阶梯值信息
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_LADDER_VALUE_TBL); i++ )
    	g_buf[i] = INIT_LADDER_VALUE_TBL[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_LADDER_VALUE_TBL) );
	
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Ladder1),
 					 (uchar*)&g_buf[0],i+1 );	
 					 	
	//阶梯电价信息
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_LADDER_PRICE_TBL); i++ )
    	g_buf[i] = INIT_LADDER_PRICE_TBL[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_LADDER_PRICE_TBL) );
	
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LadderPrice1),
 					 (uchar*)&g_buf[0],i+1 );	
 	
 	//阶梯周期 默认按月 11
 	g_buf[0] = 0x00;
 	g_buf[1] = 0x01;		//月 11
 	g_buf[2] = 0x18;
 	g_buf[3] = 0x05;		//月 11
 	g_buf[4] = 0x01;		//月 11	
 	g_buf[5] = 0x18;
 	g_buf[6] = 0x05;		//月 11
 	g_buf[7] = 0x01;		//月 11
 	for( i=8; i<15; i++ )
    	g_buf[i] = 0x00;
 	//校验和 11
	g_buf[15] = GetSum ( &g_buf[0], 15 );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,YYMM),
		 (uchar*)&g_buf[0],16 );			 		
#endif
	
	//根据剩余金额设置 11
	g_relayFlag.Bit.RelayNeedToOperate = 1;   
	if ( g_energy.Balance > 0 )		
	    g_relayFlag.Bit.RelayOn = 0;	
	else
	    g_relayFlag.Bit.RelayOn = 1;	
	
		
	            
    return;   
	           	      
}
		
				