/******************************************************************************************
*  Copyright (c) 2010, Bona Design Department(Tai Yuan)
*  All rights reserved 
*
*  FileName：   	ICCard.c
*  Author：     	Bona Meter
*  Date：  			2010-3-8 20:10
*  Revised Date：  	
*  Main Function：  this file contains all the functions processing IC card.
*  Version:			BonaV2.0
*  Note： 			 			
*********************************************************************************************/


#pragma sfr
#pragma di
#pragma ei
#pragma NOP
#pragma HALT
#pragma STOP

//#pragma interrupt INTP4 ISRForCardIn


#define _ICCard_DEFINE_
#include "include.h"

//
//card type
/////////////////////////////////////////////////////////////////////////////////
#define CLEAR_ALL_CARD              (0x51)     //总清卡 11
#define MANUFATURE_SUPER_CARD       (0x52)     //生产设置卡 11
#define OUT_SUPER_CARD              (0x53)     //出厂设置卡 11
#define CHECK_RELAY_CARD            (0x54)     //继电器检测卡 11
#define READ_BACK_CARD              (0x55)     //抄表卡 11
#define USER_CARD                   (0x56)     //用户购电卡 11
#define CLEAR_ZONE_CARD             (0x57)     //分清卡 11
#define DATE_SET_CARD             	(0x58)     //时间设置卡 11
#define CLEAR_CALIDATA_CARD        	(0x59)     //校表参数初始化卡11 
#define RETURN_MONEY_CARD        	(0x5a)     //退费卡11
#define METER_SET_CARD        		(0x5b)     //表号设置卡11
#define FORCE_RELAY_CARD        	(0x5D)     //强制跳闸和闸卡 11
#define SINGLE_CALI_CARD        	(0x5C)     //单点校正卡 11
#define MONEY_GIVEN_CARD        	(0x5E)     //补助充值卡 11
#define CALI_CHANGE_CARD        	(0x5F)     //误差快慢修正卡 11
/////////////////////////////////////////////////////////////////////////////////

//卡处理出错报警
//////////////////////////////////////////////////////////////////////////////////
//card process error status byte
#define CARD_NOT_CONSISTENT 		(0x01)		//不是合法卡 11
#define CARD_FRAME_ERR 				(0x02)		//卡上数据格式错 11
#define CARD_ZONE_ERR 				(0x04)		//分区号错 11
#define CARD_BUYCNT_ERR 			(0x08)		//购电次数不符 11

#define CARD_OVERLIMIT_ERR 			(0x10)		//超过囤积量 11
#define CARD_CARDID_ERR 			(0x20)		//卡号不符 11
#define CARD_USED_ERR 				(0x40)		//卡已使用过 11
#define CARD_STATUS_ERR 			(0x80)		//状态不符 11

#define CARD_CARDTYPE_ERR 			(0x81)		//不存在此卡类型 11
#define READ_CARD_ERR 				(0x82)		//读卡上数据失败 11

#define BUY_CARD_OPEN_ERR 			(0x51)		//购电卡开户卡状态错 11
#define BUY_CARD_NUM_ERR 			(0x52)		//购电卡购电量错 11

#define UPDATE_EEPROM_ERR 			(0x53)		//更新EEPOM出错 11
#define OVER_READNUM_ERR 			(0x54)		//超出最大抄表数量 11

//added by Roger 2015/07/24
#define CALIBRATE_INIT_ERR 			(0x55)		//校表参数卡出错 11
#define UPDATE_MOMONEY_ERR 			(0x56)		//退费卡写卡出错 11

#define RESET_CALI_CHIP_ERR 			(0x57)		//初始化计量芯片卡出错 11
//#define WRITE_BACK_ERR 			    (0x58)		//返写卡出错 11

#define FORCE_CARD_STATUS_ERR		(0x61)		//强制跳闸卡状态不符 11
#define UNAUTH_CARD_ERR				(0x62)		//非法卡 11

#define CALI_PRO_ERR				(0x71)		//校表失败 11
#define COEF_ERR					(0x72)

#define JIA_CE_TEST_ERR		(0x99)		//佳测限值到期 11

#define RF_CARD_SELECT_ERR		(0x91)
#define RF_CARD_AUTH_ERR		(0x92)
#define RF_READ_TYPE_ERR		(0x93)
#define RF_WRITE_CARD_ERR		(0x94)
//////////////////////////////////////////////////////////////////////////////////
#if (IC_CARD_MODE==RF_CARD)

/******************************************************************************************/

const uchar SELFKEY[16]={0x84,0x71,0xb5,0xbc,0xde,0x4d,0x4b,0xbe,
				0xfb,0x1d,0x45,0xa8,0x56,0xef,0x85,0xc8};

//初始化参数 11
//初始化参数 11
const uchar INIT_PRICE_TABLE[]={
	//费率电价信息	8	 11
	0x00,0x00,		//费率电价1  低字节在前 高字节在后 2字节 11
	0x00,0x00,		//费率电价2  2字节 11
	0x00,0x00,	    //费率电价3  2字节 11
	0x00,0x00,		//费率电价4  2字节 11
	0x00,0x00,		//费率电价5  2字节 11
	0x00,0x00,		//费率电价6  2字节 11	
	0x00,0x00,0x00,	//保留3字节 	 11							
	//0x00			//16	
};

const uchar INIT_PASSWORD_TABLE[]={
	0x02,               //通讯密码 4 11	
	0x00,0x00,0x00,
	//0x02		        //校验码	   16
};

const uchar INIT_YEAR_ZONE_TABLE[]={
	0x01,		//年时区数 11
	0x01,		//时段表数 11
	0x08,		//日时段表数 11
	0x01,0x01,0x01,		//第1年时区 11
	0x01,0x01,0x01,			//第2年时区 11
	0x01,0x01,0x01,			//第3年时区 11
	0x01,0x01,0x01,			//第4年时区 11
	//0x10		    //校验和	 11
};

const uchar INIT_TARIFF_TBL1[]={
	//第1时段表 费率时段表 12 13 14 
	0x04,0x00,0x00,		//第1时段表 11
	0x04,0x00,0x08,		//第2时段表 11
	0x04,0x00,0x08,		//第3时段表 11
	0x04,0x00,0x08,	    //第4时段表 11
	0x04,0x00,0x08,		//第5时段表	11
	0x04,0x00,0x08,		//第6时段表 11
	0x04,0x00,0x08,		//第7时段表 11
	0x04,0x00,0x08,		//第8时段表	11  
	0x04,0x00,0x08,		//第9时段表 11
	0x04,0x00,0x08,		//第10时段表 11
	0x04,0x00,0x08,	    //第11时段表 11
	0x04,0x00,0x08,		//第12时段表 11
	0x04,0x00,0x08,		//第13时段表 11
	0x04,0x00,0x08,		//第14时段表 11	  					
	//unsigned char Checksum10;		// 43	
};


const uchar INIT_LADDER_VALUE_TBL[]={
	//阶梯值信息	36
	0x00,0x00,		//阶梯值1  2字节 11
	0x00,0x00,		//阶梯值2  2字节 11
	0x00,0x00,		//阶梯值3  2字节 11
	0x00,0x00,		//阶梯值4  2字节 11
	0x00,0x00,		//阶梯值5  2字节 11	
	0x00,0x00,		//阶梯值6  2字节 11
	0x00,0x00,		//阶梯值7  2字节 11								
	//unsigned char Checksum6;		//11
};

const uchar INIT_LADDER_PRICE_TBL[]={
	//阶梯电价信息	37
	0x00,0x00,		//0x50,0x14, 默认5200 0.52 阶梯电价1  2字节 11
	0x00,0x00,		//阶梯电价2  2字节 11
	0x00,0x00,		//阶梯电价3  2字节 11
	0x00,0x00,	    //阶梯电价4  2字节 11
	0x00,0x00,		//阶梯电价5  2字节 11
	0x00,0x00,		//阶梯电价6  2字节	11	
	0x00,0x00,		//阶梯电价6  2字节	11
	0x00,0x00,		//阶梯电价6  2字节	11							
	//unsigned char Checksum7;		//12+1=13
};

//初始化参数 11
const char INIT_SOFTWARE_VERSION[8]={	' ',' ',
										VERSION_UPDATE_2+0X30,
										VERSION_UPDATE_1+0X30,
										'.',
										VERSION_HEAD_2+0x30,
										VERSION_HEAD_1+0x30,
										'V'																																		
										};

//added by Roger 2015/07/24
/////////////////////////////////////////////////////////////////
//const uchar RF_PASSWORD[96] = { 0x06,0x18,0x20,0x12,0x01,0x63,	//sector0
//								0x06,0x19,0x20,0x18,0x01,0x63,	//sector1 
//								0x06,0x28,0x20,0x14,0x01,0x23,	//sector2
//								0x15,0x18,0x20,0x15,0x01,0x63,	//sector3 
//								0x32,0x18,0x20,0x12,0x01,0x63,	//sector4  
//								0x56,0x38,0x20,0x12,0x01,0x63,	//sector5 																
//								 
//								0x76,0x14,0x20,0x12,0x01,0x63,
//                                0x96,0x18,0x50,0x12,0x01,0x63,
//                                0x16,0x18,0x26,0x12,0x01,0x63,
//                                0x26,0x18,0x20,0x72,0x01,0x63,
//                                0x46,0x18,0x20,0x18,0x01,0x63,
//                                0x66,0x18,0x20,0x12,0x91,0x63,
//                                0x86,0x18,0x20,0x12,0x00,0x63,
//                                0x06,0x18,0x20,0x12,0x01,0x13,
//                                0x46,0x18,0x20,0x12,0x01,0x62,
//                                0x86,0x18,0x20,0x12,0x01,0x53};
                                
const uchar RF_PASSWORD[96] = { 0xff,0xff,0xff,0xff,0xff,0xff,	//sector0
								0xff,0xff,0xff,0xff,0xff,0xff,	//sector1 
								0xff,0xff,0xff,0xff,0xff,0xff,	//sector2
								0xff,0xff,0xff,0xff,0xff,0xff,	//sector3 
								0xff,0xff,0xff,0xff,0xff,0xff,	//sector4  
								0xff,0xff,0xff,0xff,0xff,0xff,	//sector5 																
								 
								0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                
                                0xff,0xff,0xff,0xff,0xff,0xff,
                                0xff,0xff,0xff,0xff,0xff,0xff};
////////////////////////////////////////////////////////////////

#if(METER_CHIP_MODEL==0x2208)
	extern const uint16 CALIBRATE_TABLE_value[];	
#endif
/******************************************************************************************/

//function statement
/******************************************************************************************/

static uchar CheckDataFrame ( uchar *buf );


static uchar SetParaFromCard ( void );
static uchar ProcessReadbackCard ( void );


static uchar ProcessRetrunBack ( void );  
#ifdef BONUS_PADI_ENABLE 
	static uchar ProcessBonusRetrunBack ( uint32 temp32, uint16 temp16 );  
#endif 

;                
/******************************************************************************************/
/*
*****************************************************************************************
* fuction name: InitICCarVariables
*
* Description : this function initializes MCU pins 
*
* Arguments   : none
*
* returns     : none
*
* Notes     :
******************************************************************************************
*/
#ifdef PRE_PAID_ENABLE
void InitICCarVariables ( void )
{
    //卡状态判断 11

           

}
#endif	



/*
*****************************************************************************************
* fuction name: CheckDataFrame
*
* Description : 
*
* Arguments   : 1)uchar *buf : the data need to encrypt
*		2)uchar pos: the location in IC card
*		3)uchar len: the lenght of data need to encrypt
*
* returns     : null 
*
* Notes       :
******************************************************************************************
*/

static uchar CheckDataFrame ( uchar *buf )
{                
    uchar temp;
    
    if ( (buf[0] != 0xa6) || (buf[15] != 0x3a) )
    {
    	return 1; 	
    }
    
    temp = GetSum ( buf, 14 );
    if ( temp != buf[14] )
    	return 1;
    
    return 0;
}

/*
*****************************************************************************************
* fuction name: ManageICCard
*
* Description : this function process IC card when detect IC card plug in
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
void ManageRF_ICCard ( void )
{						
       
    uint16 tempInt16;
    uint32 tempInt32,tmp32_2;
    uchar i,cardType,meterMode,addr[6],judgeFlag;
    uchar *pbuf;
        					
	g_initDispCnt = LCD_CLEAR_CNT;
	DisplayCardIn ( );
		
	FeedWatchdog ( );	    
		
	//LED display set	
	//g_meterFlag.Bit.CardAndPowerupDisp = 1;	
	g_meterFlag.Bit.CycleDisp = 1;
	g_LCDSec = 0;
	g_LCDFrame = 0;		//插卡显示 11
	
	for ( i=0; i<16; i++ )
		g_buf[i] = 0;	
	//卡错误状态置0 11
    g_cardStatus = 0;
    
    //增加选卡操作 11
    if ( CV520SelectCard ( ) == FALSE )
    {   	
    	g_cardStatus = RF_CARD_SELECT_ERR;
    	goto end_ic_process;	
    }
    
    //获取卡上128字节数据 11
    //读取卡上数据 11
    pbuf = (uchar*)&g_commBuf[0].Data[0];  
    if ( ReadBlockData ( 01, (uchar*)pbuf ) == FALSE ) 
    {
    	g_cardStatus = RF_READ_TYPE_ERR;
    	goto end_ic_process;	
    } 
    
    g_meterFlag.Bit.RFInFieldFlag = 1;
    g_rfInFieldCnt = 30;
              
    //判断0x00处，判断卡类型 11	
   	pbuf = (uchar*)&g_commBuf[0].Data[0];   
	Decrypt ( pbuf, 0x10, 16, DECRYPT_KEY );   
    if ( CheckDataFrame (pbuf) != 0 )
    {
    	g_cardStatus = UNAUTH_CARD_ERR;
    	goto  end_ic_process;		
    }  
    cardType = pbuf[1];
         
	//首先判断0x10处，是否为本地区发行卡、卡号是否相符、电表模式 11		
	//CardI2CRead ( CARD_ADDR, 0X10, (uchar*)g_buf, 16 ); 
	pbuf = (uchar*)&g_commBuf[0].Data[0+0x10];  
    if ( ReadBlockData ( 02, (uchar*)pbuf ) == FALSE ) 
    {
    	g_cardStatus = RF_READ_TYPE_ERR;
    	goto end_ic_process;	
    } 
	
	pbuf = (uchar*)&g_commBuf[0].Data[0+0x10];    
	Decrypt ( pbuf, 0x20, 16, DECRYPT_KEY );    
    if ( CheckDataFrame (pbuf) != 0 )
    {
    	//g_cardStatus = CARD_NOT_CONSISTENT;		//非法卡 11
    	g_cardStatus = 0x61;
    	goto  end_ic_process;		
    }
    
    //功能卡判断  11
    if ( (cardType==CLEAR_ALL_CARD) || 		//总清卡 11
    	(cardType==MANUFATURE_SUPER_CARD) ||  //生产超级卡 11
    	(cardType==OUT_SUPER_CARD) || 		//出厂超级卡 11
    	(cardType==CHECK_RELAY_CARD) ||		//继电器测试卡 11
    	(cardType==DATE_SET_CARD) )		//时间设置卡 revised by Roger 2015/07/24
    {
	    //分区号判断 11
	    tempInt16 = ((uint16)pbuf[1]<<8) + pbuf[2];
	    if ( tempInt16 != 0x9999 )
	    {
	    	g_cardStatus = CARD_ZONE_ERR;		//分区号不符 11
	    	goto  end_ic_process;			
	    }   
	    //卡号判断 11
	    for ( i=0; i<6; i++ )
	    {
	    	if (  pbuf[8-i] != 0x99 )
	    	{
		    	g_cardStatus = CARD_CARDID_ERR;		//卡号不符 11
		    	goto  end_ic_process;		
		    }
		}	
    }
    
       
    //购电卡和退费卡需要判断卡号 11
   	if ( 	(cardType==USER_CARD) ||		//购电卡 11
   				(cardType==RETURN_MONEY_CARD) )		//退费卡 11
   	{
   		if ( (g_buyPara.BuyCount>1) ||
   			(g_buyPara.Status==USER_STATUS) ) 
        {
        	//表中卡号判断 11
	        for ( i=0; i<6; i++ )
	        {
	        	if ( g_addr.CardNum[i] != pbuf[3+i] )
	        	{
	        		g_cardStatus = CARD_CARDID_ERR;		//卡号不符 11
		    		goto  end_ic_process;		
	        	}
	        	
	        }	
        }  		   
   	}  
    
    //判断分区号 11
    //只有购电卡和分清卡需判断电表分区号 11 
    //退费卡也需判断分区号 11
    if ( (cardType==USER_CARD) ||		//购电卡 11
    		(cardType==CLEAR_ZONE_CARD) || 	//分清卡 11
    		(cardType==RETURN_MONEY_CARD) || 	//退费卡 11
    		(cardType==FORCE_RELAY_CARD) ||		//强制跳闸卡 11
    	 	(cardType==CALI_CHANGE_CARD) )		//误差调校卡 11
   { 		
    	judgeFlag = 1;
    	if ( (cardType==USER_CARD) ||		//购电卡 11    		
    			(cardType==RETURN_MONEY_CARD) ) 	//退费卡 11
    	{
    		//需增加判断购电次数<1的情况不判断 11
    		if ( g_buyPara.BuyCount < 1 )	
    			judgeFlag = 0;
    	}
    	
    	if ( judgeFlag > 0 )
    	{
    		//判断表分区号 11
	        pbuf = (uchar*)&g_commBuf[0].Data[0+0x10];
	        tempInt16 = (((uint16)pbuf[1]<<8)|(uint16)pbuf[2]);
	    	if ( g_addr.Zone != tempInt16 )
	    	{
	            g_cardStatus = CARD_ZONE_ERR;  
	            goto  end_ic_process;                    
	    	}	
    	}    	
    }
    
     
    switch ( cardType )
    {
    case CLEAR_ALL_CARD:    //总清卡  11 
    {        
        DisplayClear ( ); 
        g_initDispCnt = LCD_CLEAR_CNT;
        
        pbuf = (uchar*)&g_commBuf[0].Data[0]; 
        tmp32_2 = ((uint32)pbuf[2]<<24) + ((uint32)pbuf[3]<<16) + ((uint32)pbuf[4]<<8)+ pbuf[5];                
        ClearAllData ( tmp32_2, 10000 );																									
	#ifdef PRE_PAID_ENABLE		
		ProcessPrice( );
	#endif	
        break;
    }
    
    case MANUFATURE_SUPER_CARD: //生产超级卡 11
    {
        if ( g_buyPara.Status == MANUFACTURE_STATUS )      
        {
            g_cardStatus = SetParaFromCard ( );
            pbuf = (uchar*)&g_energy.Accumulate;
	    	for ( i=0; i<Meter_EQuan_Len; i++ ) 
	        	*pbuf++ = 0;
            pbuf = (uchar*)&g_commBuf[0].Data[0]; 
            tmp32_2 = ((uint32)pbuf[10]<<24) + ((uint32)pbuf[11]<<16) + ((uint32)pbuf[12]<<8)+ pbuf[13];  	
            g_energy.Balance = tmp32_2; 
            
            //added by Roger 2015/07/24
            g_para.MeterTpye &= ~BIT0; 	  //设置本地售电模式 保电解除 11
            
       	#ifdef PRE_PAID_ENABLE		
			ProcessPrice( );
		#endif	 
            SaveEnergy ( NORMAL_SAVE );        
        }
        else
        	g_cardStatus = CARD_STATUS_ERR;
        break;
    }
    case OUT_SUPER_CARD:    //出厂超级卡 11
    {
        //if ( g_buyPara.Status != MANUFACTURE_STATUS )
        if ( g_buyPara.Status == USER_STATUS )  //revised by Roger 2015/07/22
        {
        	g_cardStatus = CARD_STATUS_ERR;
        	break;
        }   
        if ( g_buyPara.Status == BACK_MONEY_STATUS )  //revised by Roger 2015/07/24
        {
        	g_cardStatus = CARD_STATUS_ERR;
        	break;
        }              		
        g_cardStatus = SetParaFromCard ( ); 
         
        pbuf = (uchar*)&g_energy.Accumulate;
    	for ( i=0; i<Meter_EQuan_Len; i++ ) 
        	*pbuf++ = 0;
        
        pbuf = (uchar*)&g_commBuf[0].Data[0]; 
        tmp32_2 = ((uint32)pbuf[10]<<24) + ((uint32)pbuf[11]<<16) + ((uint32)pbuf[12]<<8)+ pbuf[13];  	
        g_energy.Balance = tmp32_2; 
        g_energy.PrePaid = tmp32_2;
        
        //added by Roger 2015/07/24
      	g_para.MeterTpye &= ~BIT0; //设置本地售电模式 保电解除 11
             
    #ifdef PRE_PAID_ENABLE		
		ProcessPrice( );
	#endif	
        SaveEnergy ( NORMAL_SAVE );                                         
        break;
   	}
    case CHECK_RELAY_CARD:  //继电器检测卡  11  
    {                                  
        //g_relayFlag.Bit.RelayInTest = 1;
        g_relayFlag.Bit.RelayInTest = ~g_relayFlag.Bit.RelayInTest;
        if ( g_relayFlag.Bit.RelayInTest )        
            g_5minutesCnt = FIVE_MININUTES_CNT; 
        else
            g_5minutesCnt = 0;       
        g_relayFlag.Bit.RelayNeedToOperate = 1;                             
        break;
   	}
    case READ_BACK_CARD:    //抄表卡 11
        ProcessReadbackCard (  );
        break; 
    case USER_CARD:         //用户卡 11 
    {           
        //表状态判断 11
        if ( g_buyPara.Status == MANUFACTURE_STATUS )
        {
            g_cardStatus = CARD_STATUS_ERR;
        	break;    
        }  
        if ( g_buyPara.Status == BACK_MONEY_STATUS )  //revised by Roger 2015/07/24
        {
        	g_cardStatus = CARD_STATUS_ERR;
        	break;
        } 
        FeedWatchdog  (  );   
                     
        //g_cardStatus = ProcessUserCard (  ); 
        
        //0x00处参数  11
        //户号 11
        for ( i=0; i<6; i++ )
        {
        	g_commBuf[1].Data[6+i] =  g_commBuf[0].Data[0x13+i];
        }  
        //购电金额 11
        g_commBuf[1].Data[12] = g_commBuf[0].Data[13]; 
        g_commBuf[1].Data[13] = g_commBuf[0].Data[12]; 
        g_commBuf[1].Data[14] = g_commBuf[0].Data[11]; 
        g_commBuf[1].Data[15] = g_commBuf[0].Data[10]; 
       	//购电次数 11         
		g_commBuf[1].Data[16] = g_commBuf[0].Data[3]; 
		g_commBuf[1].Data[17] = g_commBuf[0].Data[2];   
		
		pbuf = &g_commBuf[1].Data[0]; 
		if ( (g_commBuf[0].Data[4]&0x80) == 0x80 )
			meterMode = BUY_RETURN_MODE;
		else
			meterMode = NORMAL_MODE;	
    	//更新参数 11
    	FeedWatchdog  (  );
		g_cardStatus = SetParaFromCard ( );
    	
    	g_cardStatus |= ProcessUserBuyQuan ( pbuf, meterMode, 1 ); 
                				
    #ifdef PRE_PAID_ENABLE		
		ProcessPrice( );
	#endif	         
        break;
   	}
   	
    case CLEAR_ZONE_CARD:   //分清卡 11 
   	{        
        
    	
    #ifdef TARIFF_ENABLE
    	pbuf = (uchar*)&g_energy.Accumulate; 
    	for( i=0; i<28; i++ )
    		g_commBuf[0].Data[32+i]	= pbuf[i]; 
    #else
    	tempInt32 = g_energy.Accumulate;
    #endif
    
    	tempInt16 = g_addr.Zone;
    	for( i=0; i<6; i++ )
    		addr[i] = g_addr.MeterAddr[i];
    	
    	DisplayClear ( ); 
        g_initDispCnt = LCD_CLEAR_CNT;
    	pbuf = (uchar*)&g_commBuf[0].Data[0]; 
        tmp32_2 = ((uint32)pbuf[2]<<24) + ((uint32)pbuf[3]<<16) + ((uint32)pbuf[4]<<8)+ pbuf[5];                
        ClearAllData ( tmp32_2, 10000 );
        	        
        FeedWatchdog  (  );
        g_buyPara.Status = OUT_STATUS;
    
    #ifdef TARIFF_ENABLE
    	pbuf = (uchar*)&g_energy.Accumulate; 
    	for( i=0; i<28; i++ )
    		pbuf[i] = g_commBuf[0].Data[32+i]; 
    	g_energy.PosAccumulate = g_energy.Accumulate;
    #else
    	g_energy.Accumulate = tempInt32;
        g_energy.PosAccumulate = tempInt32;
    #endif   
                
        g_energy.PrePaid = tmp32_2;
        g_addr.Zone = tempInt16;
        for( i=0; i<6; i++ )
    		g_addr.MeterAddr[i] = addr[i];
        
        //added by Roger 2015/07/24
        g_para.MeterTpye &= ~BIT0;  //设置本地售电模式 保电解除 11
        
        SaveEnergy ( NORMAL_SAVE ); 
          
    	g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
	    FeedWatchdog  (  );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
				(uchar*)&g_addr.Zone,Meter_Addr_Len ) != 0 )
			g_cardStatus = UPDATE_EEPROM_ERR;	
			
		g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
	    FeedWatchdog  (  );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
				(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len ) != 0 )
			g_cardStatus = UPDATE_EEPROM_ERR;
			
	#ifdef PRE_PAID_ENABLE		
		ProcessPrice( );
	#endif	
		
        break; 
    }
    
    case DATE_SET_CARD:   //时间设置卡 11
    {
    #ifdef RTC_8025T 
    	pbuf = (uchar*)&g_commBuf[0].Data[0];
    	
    	SetTime ( pbuf );
    	
    	g_date.year = pbuf[2];
    	g_date.month = pbuf[3];
    	g_date.day = pbuf[4];
    	
    	g_date.hour = pbuf[5];
    	g_date.min = pbuf[6];
    	g_date.sec = pbuf[7];
    #endif	
    	
    	break;
	}
	
	#if(METER_CHIP_MODEL==0x2208)
	case CLEAR_CALIDATA_CARD:	//校表参数初始化卡 11
	{
    	if ( g_buyPara.Status == USER_STATUS ||
        	g_buyPara.Status == RETURN_MONEY_CARD )
    	{
            g_cardStatus = CARD_STATUS_ERR;
        	break;    
        }
    	
    	g_initDispCnt = LCD_CLEAR_CNT;
		DisplayCali ( 0 );
			
    	CopyRamData ( (uchar*)&g_cl2208para.pstart, (uchar*)&CALIBRATE_TABLE_value[0],CALIREG_NUM*2 );
					
		g_cl2208para.Reserved = 0;
		g_factor.UFactor = U_FACTOR;
		g_factor.IFactor = IL_FACTOR;
		g_factor.PFactor = P_FACTOR;
		g_factor.Reserved[0] = 0;
		g_factor.Reserved[1] = 0;
		g_factor.Reserved[2] = 0;
		
		
		//FeedWatchdog (  );	
		SoftResetCl2208 ( );
		FeedWatchdog (  );
		CalibrateCl2208 ( );
    	break;	
    }
    	//校正卡 11
    case SINGLE_CALI_CARD:
    {
    	g_commBuf[0].Data[1] = 0x00;
    	g_commBuf[0].Data[2] = 0x22;
    	g_commBuf[0].Data[3] = 0x00;
    	g_commBuf[0].Data[4] = 0x00;		//220.000V
    	
    	g_commBuf[0].Data[5] = 0x00;
    	g_commBuf[0].Data[6] = 0x00;
    	g_commBuf[0].Data[7] = 0x50;
    	g_commBuf[0].Data[8] = 0x00;		//005.000A
    	    	   	
    	if ( g_commBuf[0].Data[0] == 1 )	//100%Ib，1.0(L) 11
    	{
    		g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 1 );
			
			g_commBuf[0].Data[9] = 0x01;
	    	g_commBuf[0].Data[10] = 0x10;
	    	g_commBuf[0].Data[11] = 0x00;
	    	g_commBuf[0].Data[12] = 0x00;		//01.100000	KW					
			if ( CaliGainPara ( &g_commBuf[0].Data[1] ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
    	}
    	else if ( g_commBuf[0].Data[0] == 2 ) //100%Ib，0.5L(L) 111
    	{
    		g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 2 );
			
			g_commBuf[0].Data[9] = 0x00;
	    	g_commBuf[0].Data[10] = 0x55;
	    	g_commBuf[0].Data[11] = 0x00;
	    	g_commBuf[0].Data[12] = 0x00;		//00.550000	KW	
	    	
			if ( CaliPhasePara ( &g_commBuf[0].Data[1] ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
    	}
		else if ( g_commBuf[0].Data[0] == 3 ) //5%Ib，1.0(L) 11
		{
			g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 3 );
			
			g_commBuf[0].Data[5] = 0x00;
    		g_commBuf[0].Data[6] = 0x00;
    		g_commBuf[0].Data[7] = 0x02;
    		g_commBuf[0].Data[8] = 0x50;		//000.250A
    	
			g_commBuf[0].Data[9] = 0x00;
	    	g_commBuf[0].Data[10] = 0x05;
	    	g_commBuf[0].Data[11] = 0x50;
	    	g_commBuf[0].Data[12] = 0x00;		//00.055000	KW	
	    	
			if ( CaliOffsetPara ( &g_commBuf[0].Data[1] ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
		}
    	break;
    }
	#else if (METER_CHIP_MODEL==0x8302)    
    case CLEAR_CALIDATA_CARD:	//校表参数初始化卡 11
    {
    	//表状态判断 11
        if ( g_buyPara.Status == USER_STATUS ||
        	g_buyPara.Status == RETURN_MONEY_CARD )
        {
            g_cardStatus = CARD_STATUS_ERR;
        	break;    
        }
    	
    	g_initDispCnt = LCD_CLEAR_CNT;
		DisplayCali ( 0 );
			
    	//CopyRamData ( (uchar*)&g_cl2208para.pstart, (uchar*)&CALIBRATE_TABLE_value[0],sizeof(CALI_REG_ORDER)*2 );
		pbuf = (uchar*)&g_rn8302para.gsua;
		for ( i=0; i<32; i++ )
		{
			*pbuf++ = 0;		
		}	
		//软复位 11
		if ( Write_Register_CMD(SOFTRESET, RESET_CMD) != 0 )
		{
            g_cardStatus = RESET_CALI_CHIP_ERR;
        	break;    
        }
		FeedWatchdog ( );
		//延时20ms 11
		Delay1MsTime( 20 );
		FeedWatchdog ( );
		
		if ( StoreCaliPara ( ) != 0 )
		{
			g_cardStatus = CALIBRATE_INIT_ERR;	//revised by Roger 2015/07/24
			break;
		}
										
		FeedWatchdog (  );
		SetRN8302_Register ( );
    	break;	
    }	
    	//校正卡 11
    case SINGLE_CALI_CARD:
    {
    	if ( g_commBuf[0].Data[0] == 1 )	//100%Ib，1.0(L) 11
    	{
    		g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 1 );
		
			if ( CaliGainPara ( ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
    	}
    	else if ( g_commBuf[0].Data[0] == 2 ) //100%Ib，0.5L(L) 111
    	{
    		g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 2 );
			
			if ( CaliPhasePara ( ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
    	}
		else if ( g_commBuf[0].Data[0] == 3 ) //5%Ib，1.0(L) 11
		{
			g_initDispCnt = LCD_CLEAR_CNT;
			DisplayCali ( 3 );
			
			if ( CaliOffsetPara ( ) != 0 )
			{
				g_cardStatus = CALI_PRO_ERR;
        		break;
			}	
		}
    	break;
    }
	#endif
    
    //added by Roger 2015/07/24	
    case RETURN_MONEY_CARD:	//退费卡 11
    {
    	//表状态判断 11
        if ( g_buyPara.Status != USER_STATUS )
        {
            g_cardStatus = CARD_STATUS_ERR;
        	break;    
        }
    	
    	
    	 
	    if ( g_cardStatus != 0 ) 
	    	break;
	    
	        
    	//返写退费返写信息A0~AF 11
	    if ( ProcessRetrunBack ( ) != 0 )
	    {
	        g_cardStatus = UPDATE_MOMONEY_ERR;	
	        break;
	    }
	    
	    //处理表内剩余金额及状态 跳闸、报警灯亮、液晶常显--TF--标识 11
	    //表计处于退费状态，可以插卡插卡退费前剩余金额 11
	    //表计此时只认分清卡、总清卡，重新开户才能用,不认购电卡、生产、出厂超级卡11
	    g_buyPara.Status = BACK_MONEY_STATUS;
	    //更新EEPROM 11
    	g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
    	if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
			(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len ) != 0 )
		{
			g_cardStatus = UPDATE_MOMONEY_ERR;	
	        break;	
		}
	    
    	break;
    }
    
    //added by Roger 2015/10/17	
    case METER_SET_CARD:	//表号设置卡 11   
    {
		pbuf = (uchar*)&g_commBuf[0].Data[0];   
		
		
		for ( i=0; i<6; i++ )
			g_addr.MeterAddr[i] = pbuf[7-i];	
		
		g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
		StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
				(uchar*)&g_addr.Zone,Meter_Addr_Len );
					    	
    	break;
    }	
    
    //强制跳闸和闸卡 11
    case FORCE_RELAY_CARD:
    {
    	pbuf = (uchar*)&g_commBuf[0].Data[0];  
    	if ( pbuf[2] == 0x1B ) //强制跳闸 11
		{
			if ( (g_para.MeterTpye&BIT0) == BIT0 )		//保电模式 11
			{
				g_cardStatus = FORCE_CARD_STATUS_ERR;
				break;	
			}	
			
			g_relayFlag.Bit.RelayOn = 1;
           	g_relayFlag.Bit.RelayNeedToOperate = 1;
           		           		
           	g_para.MeterTpye |= BIT1;  //设置远程拉闸 11
	      	g_meterStatus3.Bit.RelayCmdStatus = 1;
	           	
		}
    	else if( pbuf[2] == 0x2B ) //跳闸取消 11
		{		 
           	g_para.MeterTpye &= ~BIT1;  //取消远程拉闸 11	
				
           	g_meterStatus3.Bit.RelayCmdStatus = 0;
		}
    	else if( pbuf[2] == 0x1A ) //保电 11
		{
			g_relayFlag.Bit.RelayOn = 0;				
           	g_relayFlag.Bit.RelayNeedToOperate = 1;  //执行合闸动作 11
           		
           	g_para.MeterTpye |= BIT0;  //设置保电模式 11 
           	
	      	g_meterStatus3.Bit.KeepRelay = 1; 
	           	
	      	g_para.MeterTpye &= ~BIT1;  //取消远程拉闸 11	
	       	g_meterStatus3.Bit.RelayCmdStatus = 0;          	          	
		}
		else if( pbuf[2] == 0x2A ) //保电解除 11
		{
			g_para.MeterTpye &= ~BIT0; 	
			g_meterStatus3.Bit.KeepRelay = 0;			
		}
		    	
    	g_para.Checksum = GetSum ( (uchar*)&g_para.LimitPower, Meter_Para_Len-1 );
       	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LimitPower),
			(uchar*)&g_para.LimitPower,Meter_Para_Len );
				
    	break;
    }
    
    //补助金额充值卡 11
    case MONEY_GIVEN_CARD:
    {
    	if ( g_buyPara.Status != USER_STATUS ) 
    	{
    		g_cardStatus = CARD_STATUS_ERR;
    		break;	
    	}
    		
    	pbuf = (uchar*)&g_commBuf[0].Data[0];
    	//用户编号判断 11
		if ( g_buyPara.BuyCount > 0 ) //已发生过购电 11
		{						
			judgeFlag = BIT0+BIT1;
			for ( i=0; i<6; i++ )
	        {
	        	if ( pbuf[2+i] != 0x99 )
	        	{
	        		judgeFlag &= ~BIT0;	
	        	}
	        	
	        	if ( (g_addr.CardNum[i] != pbuf[6+i]) )
	        	{
	        		judgeFlag &= ~BIT1;		        				
	        	} 	 	
	        }	
	        
	        if ( judgeFlag == 0 ) 
	        {
	        	g_cardStatus = CARD_CARDID_ERR;
				break;	
			}		       	        	  				
		}
		
		//补助金额处理 11
		//获取补助次数 11
    	if ( pbuf[13] > g_energy.BonusBuyCount )
    	{
    		//获取补助金额 11
    		tempInt32 = pbuf[8]; 
			tempInt32 = (tempInt32<<8) | pbuf[9]; 
			tempInt32 = (tempInt32<<8) | pbuf[10]; 
			tempInt32 = (tempInt32<<8) | pbuf[11];	
				
    		if ( (pbuf[12]&BIT0) == BIT0 )	//结算日累计 11
    		{   			
    			tempInt32 += g_energy.BonusBalance;		
    		}
    		
			//补助次数 11
			tempInt16 = pbuf[13];	
    	}
    	else
    	{
    		//获取补助金额 11
    		tempInt32 = g_energy.BonusBalance; 
			//补助次数 11
			tempInt16 = g_energy.BonusBuyCount;	
    	}
    
    #ifdef BONUS_PADI_ENABLE	
		g_cardStatus = ProcessBonusRetrunBack ( tempInt32,  tempInt16 ); 
		if ( g_cardStatus != 0 )
			break;	
    #endif
    			
    	g_energy.BonusBuyCount = pbuf[13];    		   		    	
    	g_energy.BonusMode = pbuf[12];  			
    	g_energy.BonusBalance = tempInt32;		

    	if ( (pbuf[12]&BIT0) == BIT0 )	//结算日累计 11
    		g_energy.BonusBuyQuan = tempInt32-g_energy.BonusBalance;			
    		
    		
    	SaveEnergy ( NORMAL_SAVE ); 
    
    #ifdef BONUS_PADI_ENABLE		
    	StoreBonusBuyHistroy ( );
    #endif
    					
    	break;
    }	

#if(CALI_CHANGE_CARD_ENABLED==1)	    
    //误差校正卡 11
    case CALI_CHANGE_CARD:
    {
    	pbuf = (uchar*)&g_commBuf[0].Data[0];  
    	if ( pbuf[2] <= COEF_MAX )  
		{				
			g_RunCoef = pbuf[2];							
		}
		else
		{
			g_cardStatus = COEF_ERR;
		}	
    	break;	
    }	
#endif
    	    	
    default:
        g_cardStatus = CARD_CARDTYPE_ERR;
        break;   
    }
    
    if ( g_cardStatus != 0 )
        goto end_ic_process;    
                          
    
end_ic_process:
    //关闭电源  11
    IC_POWER_OFF;
	FeedWatchdog (  );	
	
	//g_initDispCnt = 0;
	
    if ( g_cardStatus != 0 )
    {
        g_cardFlag.Bit.ICCardRightIn = 0;
        
        //蜂鸣器处理  11   
	    g_BeepDelay = BEEP_DELAY_2S;
	    g_BeepCnt = 0;
	    SPEAKER_L();
    }
    else
    {
        g_cardFlag.Bit.ICCardRightIn = 1;
        
        //蜂鸣器处理  11 
        g_BeepDelay = BEEP_DELAY_1S;        
	    g_BeepCnt = 3;
    }
    
    
    
    //如果之前是报警电量断开继电器，此时插入任何卡均可闭合继电器 11
    if( g_relayFlag.Bit.RelayAlarmOn )
    {
        g_relayFlag.Bit.RelayAlarmOn = 0;
        if ( g_energy.Balance > 0 )
            if( g_relayFlag.Bit.RelayOn == 0 )
            {
                g_relayFlag.Bit.RelayNeedToOperate = 1;
                
                //ALARM_OFF();		//报警灯灭  11 
            }
   	}
   	
   	//赊欠跳闸 到零处理 11
   	if ( g_relayFlag.Bit.BalanceZeroHappened )
   	{  	    
   	    g_relayFlag.Bit.BalanceZero5MinFlg = 1;
   	}
   	
   	//如果之前是过压保护断开继电器，此时插入任何卡均可闭合继电器 11
   	if ( g_errStatus.Bit.OverVoltage )
   	{
   	    g_adSampleCnt = AD_SAMPLE_3S;
   	    if ( g_energy.Balance > 0 )
            if( g_relayFlag.Bit.RelayOn == 0 )
                g_relayFlag.Bit.RelayNeedToOperate = 1;       	    
   	}

//负载跳闸使能 11
#if(OVER_POWER_RELAY_OFF_EANBLED==1)   	
   	//如果之前是过载保护断开继电器，此时插入任何卡均可闭合继电器 11
   	if ( g_errStatus.Bit.OverPower )
   	{
   	    g_errStatus.Bit.OverPower = 0;
   	    g_OverPowerFlagCnt = 0;		//added by Roger 2013/09/07
   	    
   	    if ( g_energy.Balance > 0 )
            if( g_relayFlag.Bit.RelayOn == 0 )
                g_relayFlag.Bit.RelayNeedToOperate = 1;       	    
   	}
#endif

	//恶性负载使能 11
#if(MALIGNANT_LOAD_CHK_EANBLED==1)	
	//如果之前是过载保护断开继电器，1分钟后可闭合继电器 11
	if(g_errStatus.Bit.RLoadHappened)
	{
		g_errStatus.Bit.RLoadHappened = 0;
		for ( i=0; i<8; i++ )
    	{
    	    g_curRLoad[i].PRms = 0;
    	    g_curRLoad[i].SRms = 0;    
    	} 	
	}
#endif
		   		
	//由于使用通讯缓冲区，将通讯通道重置 11
#ifdef IR_CHANNEL_ENABLE
	InitIR();
	ResetIRComm();
#endif	
	
#ifdef RS485_CHANNEL_ENABLE
	InitRS485();
	ResetRS485Comm();
#endif	
   	
#ifdef LADDER_ENABLE								
	g_meterFlag.Bit.LadderProcess = 1;
#endif	
	
	
	
	return;		
}

/*
*****************************************************************************************
* fuction name: ClearAllData
*
* Description : this function process clear all data in meter
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
void ClearAllData ( uint32 preBuy, uint16 price )
{        
    uchar *pchar;
    uchar i,len,len1;
    uint32 tempL;
    
    //清零记录 11
	I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,TotalMeterClearCnt), 
 			&g_buf[0], 3, 1  ) ;
  	tempL = BCDToHex( &g_buf[0], 3 );
  	tempL++;
  	tempL = Hex32ToBCD( tempL );
	g_buf[0] = (uchar)tempL&0xff;
	g_buf[1] = (uchar)(tempL>>8)&0xff;
	g_buf[2] = (uchar)(tempL>>16)&0xff;			
	EEPROM_NOWP();
	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,TotalMeterClearCnt), 
 			&g_buf[0], 3, 1  ) ;
	EEPROM_WP();
		
	for ( i=0; i<9; i++ )
	{
		I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last9MeterClear)-18*i, 
				&g_buf[0], 18, 1  ) ;
		
		EEPROM_NOWP();
    	I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last10MeterClear)-18*i, 
    		&g_buf[0], 18, 1  );
		EEPROM_WP();
		
		Delay1MsTime ( 5 );
		
		FeedWatchdog ( );
	}
	g_buf[0] = g_date.year;
	g_buf[1] = g_date.month;
	g_buf[2] = g_date.day;
	g_buf[3] = g_date.hour;
	g_buf[4] = g_date.min;
	g_buf[5] = g_date.sec;
	g_buf[6] = 0x78;
	g_buf[7] = 0x56;
	g_buf[8] = 0x34;
	g_buf[9] = 0x12;
	tempL = Hex32ToBCD( g_energy.PosAccumulate );				
	g_buf[10] = (uchar)tempL&0xff;
	g_buf[11] = (uchar)(tempL>>8)&0xff;
	g_buf[12] = (uchar)(tempL>>16)&0xff;			
	g_buf[13] = (uchar)(tempL>>24)&0xff;
	tempL = Hex32ToBCD( g_energy.NegAccumulate );				
	g_buf[14] = (uchar)tempL&0xff;
	g_buf[15] = (uchar)(tempL>>8)&0xff;
	g_buf[16] = (uchar)(tempL>>16)&0xff;			
	g_buf[17] = (uchar)(tempL>>24)&0xff;
	EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,Last1MeterClear), 
    		&g_buf[0], 18, 1  );
	EEPROM_WP();
	Delay1MsTime ( 5 );
	       
    for ( i=0; i<48; i++ )
    { 
        g_buf[i] = 0;
    }
    
    //EEPROM数据清零 11
    //////////////////////////////////////////////////////////////       
    //掉电数据保存区清零 11
    len = (uchar)(offsetof(EEPROM_DATA,PSTART1)&0xff);
    len >>= 4;
    for( i=0; i<len; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //清零记录和校表参数不清零 11
    len = (uchar)((offsetof(EEPROM_DATA,Zone)&0xff)>>4);
    len1 = (uchar)(offsetof(EEPROM_DATA,TotalMeterClearCnt)>>4);
    for( i=len; i<len1; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //
    len = (uchar)(offsetof(EEPROM_DATA,Zone_B)>>4);        
    for( i=len; i<EEPROM_PAGES; i++ )
    {
        EEPROM_NOWP();
        I2CWrite ( EEPROM_ADDR, 16*((uint16)i), g_buf, 16 ,1 );
        EEPROM_WP(); 
        Delay1MsTime ( 5 );
        FeedWatchdog  (  );        
    }
    
    //////////////////////////////////////////////////////////////
    
    //通讯地址不清  11
    pchar = (uchar*)&g_addr.Zone;
    for ( i=0; i<8; i++ )
    { 
        *pchar++ = 0;
    }
    for ( i=0; i<6; i++ )
        if ( ((g_addr.MeterAddr[i]&0x0f) == 0x0f) ||
              ((g_addr.MeterAddr[i]&0xf0) == 0xf0)  )
            break;
    if ( i < 6 )
    {
        for ( i=0; i<8; i++ )
        {
            g_addr.MeterAddr[i] = 0x11; 
        }               
    }
    //表地址保存 11
    FeedWatchdog ( );
	g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
		(uchar*)&g_addr.Zone,Meter_Addr_Len );
    
    
    //可以全部清零 11
    pchar = (uchar*)&g_buyPara.BuyCount;
    for ( i=0; i<16; i++ )
    { 
        *pchar++ = 0;
    }    
    g_errStatus.Byte = 0;             
    //报警金额1 2 11
    g_buyPara.Alarm1 = ALARM1_DEFAULT;
    g_buyPara.Alarm2 = ALARM2_DEFAULT;			    
    //预置金额 11
    g_buyPara.BuyQuan = 0;
    //功率因数限值 11
    g_buyPara.FactorLimit = 1000;
    //功率因数对应功率限值 11
	g_buyPara.FactorPower = 0;
    g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
	FeedWatchdog ( );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
		(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len );
					
    
    //参数预置 11
    g_para.LimitPower = MAX_POWER_LIMIT;
    g_para.MaximBalance = MAX_BALANCE_LIMIT;
    g_para.CreditLimit = CREDIT_LIMIT;
    g_para.CurrentRatio = CURRENT_RATIO;   
    g_para.Price = price;
    g_para.BonusMoneyNum = 1;
    g_para.MeterTpye = 0; //设置本地售电模式 保电解除11
    g_meterStatus3.Bit.KeepRelay = 0; 
    g_meterStatus3.Bit.RelayCmdStatus = 0;
    g_meterStatus3.Bit.StatusMeter = 0;		//退费状态 11
    g_para.Checksum = GetSum ( (uchar*)&g_para.LimitPower, Meter_Para_Len-1 );
	FeedWatchdog ( );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LimitPower),
		(uchar*)&g_para.LimitPower,Meter_Para_Len );
           
    //电量相关 11
    pchar = (uchar*)&g_energy.Accumulate;
    for ( i=0; i<Meter_EQuan_Len; i++ ) 
        *pchar++ = 0;
    g_price = price;
    g_energy.Balance = preBuy;	 
    g_energy.PrePaid = preBuy;   
    SaveEnergy( NORMAL_SAVE );
    
    //密码初始化为02 000000
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_PASSWORD_TABLE); i++ )
    	g_buf[i] = INIT_PASSWORD_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_PASSWORD_TABLE) );
    StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,PASSWORD),
		(uchar*)&g_buf[0],i+1 );
	
	//初始化软件版本号 11
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_SOFTWARE_VERSION); i++ )
    	g_buf[i] = INIT_SOFTWARE_VERSION[i];
    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,SoftVersion), g_buf, 
    			sizeof(INIT_SOFTWARE_VERSION) ,1 );
    EEPROM_WP(); 
			         
#ifdef TARIFF_ENABLE
	//费率电价信息
	FeedWatchdog ( );
    for( i=0; i<sizeof(INIT_PRICE_TABLE); i++ )
    	g_buf[i] = INIT_PRICE_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_PRICE_TABLE) );
    StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,TariffPrice1),
		(uchar*)&g_buf[0],i+1 );
  		    
	//时区 费率初始化 11
    //年时区数 11
    FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_YEAR_ZONE_TABLE); i++ )
    	g_buf[i] = INIT_YEAR_ZONE_TABLE[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_YEAR_ZONE_TABLE) );

    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,YearZoneNum), 
                    g_buf, i+1, 1  );
	EEPROM_WP();
    
    
	//第1时段表 费率时段表 12 13 14 
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_TARIFF_TBL1); i++ )
    	g_buf[i] = INIT_TARIFF_TBL1[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_TARIFF_TBL1) );

    EEPROM_NOWP();
    I2CWrite ( EEPROM_ADDR, offsetof(EEPROM_DATA,HHMMNN1), 
                    g_buf, i+1, 1  );
	EEPROM_WP();	
#endif

#ifdef LADDER_ENABLE	
	//阶梯值信息
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_LADDER_VALUE_TBL); i++ )
    	g_buf[i] = INIT_LADDER_VALUE_TBL[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_LADDER_VALUE_TBL) );
	
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Ladder1),
 					 (uchar*)&g_buf[0],i+1 );	
 					 	
	//阶梯电价信息
	FeedWatchdog ( );
	for( i=0; i<sizeof(INIT_LADDER_PRICE_TBL); i++ )
    	g_buf[i] = INIT_LADDER_PRICE_TBL[i];
    g_buf[i] = 	GetSum ( (uchar*)&g_buf[0], sizeof(INIT_LADDER_PRICE_TBL) );
	
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LadderPrice1),
 					 (uchar*)&g_buf[0],i+1 );	
 	
 	//阶梯周期 默认按月 11
 	g_buf[0] = 0x00;
 	g_buf[1] = 0x01;		//月 11
 	g_buf[2] = 0x18;
 	g_buf[3] = 0x05;		//月 11
 	g_buf[4] = 0x01;		//月 11	
 	g_buf[5] = 0x18;
 	g_buf[6] = 0x05;		//月 11
 	g_buf[7] = 0x01;		//月 11
 	for( i=8; i<15; i++ )
    	g_buf[i] = 0x00;
 	//校验和 11
	g_buf[15] = GetSum ( &g_buf[0], 15 );
	StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,YYMM),
		 (uchar*)&g_buf[0],16 );			 		
#endif
	
	//根据剩余金额设置 11
	g_relayFlag.Bit.RelayNeedToOperate = 1;   
	if ( g_energy.Balance > 0 )		
	    g_relayFlag.Bit.RelayOn = 0;	
	else
	    g_relayFlag.Bit.RelayOn = 1;	
	
		
	            
    return;   
	           	      
}
				

/*
*****************************************************************************************
* fuction name: SetParaFromCard
*
* Description : this function process parameter set of super card
*
* Arguments   : uchar *buf
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
static uchar SetParaFromCard ( void )
{       
    
    uchar updateFlag,i,cnt,j;
    uchar *pbuf;
   
    //0X00和0x10处数据已解密 11
    
    //0x00 处参数 11
    //CardI2CRead ( CARD_ADDR, 0X00, (uchar*)g_buf, 16 ); 
 	pbuf = (uchar*)&g_commBuf[0].Data[0];      
     
    //购电次数02H~03H 2字节11
    //g_buyPara.BuyCount = ((uint16)pbuf[2]<<8) + pbuf[3];
    //更新标志 04H 1字节11
    updateFlag = pbuf[4]; 
    //报警启用标识11
    //g_buyPara.AlarmSet = pbuf[5]; 
    //报警金额1 06H~07H 2字节11
    g_buyPara.Alarm1 = ((uint16)pbuf[6]<<8) + pbuf[7];
    //报警金额2 08H~09H 2字节11
    g_buyPara.Alarm2 = ((uint16)pbuf[8]<<8) + pbuf[9];
    //预置或购电金额 4字节 4位小数11
    //g_buyPara.BuyQuan = ((uint32)pbuf[10]<<24) + ((uint32)pbuf[11]<<16) + ((uint32)pbuf[12]<<8)+ pbuf[13];
   	
    
    //表状态：生产、出厂、用户11
    if ( pbuf[1]==MANUFATURE_SUPER_CARD )
    	g_buyPara.Status = 	MANUFACTURE_STATUS;
    else if ( pbuf[1]==OUT_SUPER_CARD )
    	g_buyPara.Status = 	OUT_STATUS;
   	else if ( pbuf[1]==USER_CARD )
    	g_buyPara.Status = 	USER_STATUS;
    
    FeedWatchdog (  );			
    //更新EEPROM 11
    g_buyPara.Checksum = GetSum ( (uchar*)&g_buyPara.BuyCount, Meter_Buy_PARA_Len-1 );
    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,BuyCount),
			(uchar*)&g_buyPara.BuyCount,Meter_Buy_PARA_Len ) != 0 )
		return UPDATE_EEPROM_ERR;
		
   
    //0x10处参数 分区号、卡号、模式字、表号 11
    if ( (g_buyPara.Status != USER_STATUS) || 
    	((g_buyPara.Status == USER_STATUS)&&(g_buyPara.BuyCount==0)))
    {
	    //CardI2CRead ( CARD_ADDR, 0X10, (uchar*)g_buf, 16 ); 
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x10];     
	    g_addr.Zone = ((uint16)pbuf[1]<<8) + pbuf[2];
	    for ( i=0; i<6; i++ )
	    	g_addr.CardNum[5-i] = pbuf[8-i];
	    //g_addr.BuyMode = pbuf[9];
	    
	    //revised by Roger 2015/07/22	    
	    //for ( i=0; i<4; i++ )
	    //	g_addr.MeterAddr[3-i] = pbuf[10+i];	    
	    //g_addr.MeterAddr[4] = 0x00;
	    //g_addr.MeterAddr[5] = 0x00;
	    
	    FeedWatchdog (  );
	    //更新EEPROM 11
	    g_addr.Checksum = GetSum ( (uchar*)&g_addr.Zone, Meter_Addr_Len-1 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Zone),
				(uchar*)&g_addr.Zone,Meter_Addr_Len ) != 0 )
			return UPDATE_EEPROM_ERR;	
	}
      	
    //0x20处参数 11
    //if ( updateFlag & BIT0 )
    if ( ( updateFlag & BIT0 ) || 
    	(g_buyPara.BuyCount==1) )		//第1次购电参数更新问题 revised 2015/11/19 11
    {
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x20];  
	    if ( ReadBlockData ( 8, (uchar*)pbuf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	    
	    //CardI2CRead ( CARD_ADDR, 0X20, (uchar*)g_buf, 16 );  
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x20];   
		Decrypt ( pbuf, 0x80, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (pbuf) != 0 )
	    {
	    	//return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    	return 0x63;
	    }
	    //限电功率 hex 11
	    g_para.LimitPower = ((uint16)pbuf[1]<<8) + pbuf[2];
	    //最大囤积量 BCD 11
	    g_para.MaximBalance = (((uint16)pbuf[3]<<8) + pbuf[4]);
	    //赊欠限额 11
	    g_para.CreditLimit =  (((uint32)pbuf[5]<<8)+ pbuf[6])*100;
	    //电流互感比 11
	    g_para.CurrentRatio = (((uint16)pbuf[7]<<8)+ pbuf[8]);
	    //当前电价 11
	    g_para.Price = (uint16)(((uint32)pbuf[9]<<24) + ((uint32)pbuf[10]<<16) + ((uint32)pbuf[11]<<8)+ pbuf[12]);
	    
	    FeedWatchdog (  );	
	    //更新EEPROM 11
	    g_para.Checksum = GetSum ( (uchar*)&g_para.LimitPower, Meter_Para_Len-1 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LimitPower),
				(uchar*)&g_para.LimitPower,Meter_Para_Len ) != 0 )
			return UPDATE_EEPROM_ERR;		
    }
    

#ifdef TARIFF_ENABLE		
    //0x30处参数 费率电价 11
    if ( (updateFlag & BIT1) || 
    	(g_buyPara.BuyCount==1) )
    {
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x30];  
	    if ( ReadBlockData ( 9, (uchar*)pbuf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	     
	    pbuf = (uchar*)&g_commBuf[0].Data[0+0x30];    
		Decrypt ( pbuf, 0x90, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (pbuf) != 0 )
	    {
	    	//return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    	return 0x64;
	    }
	    
	    //更新到EEPROM中 11
	    //高低位换位 11
	    for ( i=0; i<6; i++ )
	   	{
	    	pbuf[2*i] = pbuf[2*i+2];
	    }
	    for ( i=12; i<15; i++ )
	    	pbuf[i] = 0;	
	    pbuf[15] = GetSum ( pbuf, 15 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,TariffPrice1),
				(uchar*)pbuf,16 ) != 0 )
			return UPDATE_EEPROM_ERR;	    
    }
#endif

#ifdef LADDER_ENABLE   
    //0x40处参数 阶梯值 11
    if ( (updateFlag & BIT2) || 
    	(g_buyPara.BuyCount==1) )
    { 
	    if ( ReadBlockData ( 10, (uchar*)g_buf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	    
	    //pbuf = (uchar*)&g_commBuf[1].Data[0];    
		Decrypt ( g_buf, 0, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (g_buf) != 0 )
	    {
	    	//return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    	return 0x65;
	    }
	    
	    //更新到EEPROM中 11
	    //高低位换位 11
	    for ( i=0; i<5; i++ )
	    {
	    	g_buf[2*i] = g_buf[2*i+2];
	    }	
	    g_buf[10] = GetSum ( g_buf, 10 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,Ladder1),
				(uchar*)g_buf,11 ) != 0 )
			return UPDATE_EEPROM_ERR;	    
    }

   	
   	//0x50处参数 阶梯电价 11
    if ( (updateFlag & BIT2) || 
    	(g_buyPara.BuyCount==1) )
    {
	    if ( ReadBlockData ( 12, (uchar*)g_buf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	     
		Decrypt ( g_buf, 0, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (g_buf) != 0 )
	    {
	    	//return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    	return 0x66;
	    }
	    
	    //更新到EEPROM中 11
	    //高低位换位 11
	    for ( i=0; i<6; i++ )
	   	{
	    	g_buf[2*i] = g_buf[2*i+2];
	    }	
	    g_buf[12] = GetSum ( g_buf, 12 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,LadderPrice1),
				(uchar*)g_buf,13 ) != 0 )
			return UPDATE_EEPROM_ERR;	    
    }
		
    //0x1E0处参数 阶梯累计周期 11
    if ( (updateFlag & BIT2) || 
    	(g_buyPara.BuyCount==1) )
    {
	    if ( ReadBlockData ( 0x12, (uchar*)g_buf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    } 
	      
		Decrypt ( g_buf, 0, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (g_buf) != 0 )
	    {
	    	//return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    	return 0x69;
	    }
	    
	    //更新到EEPROM中 11
	    //高低位换位 11
	    for ( i=0; i<5; i++ )
	   	{
	    	g_buf[i] = g_buf[i+1];
	    }	
	    I2CRead ( EEPROM_ADDR, offsetof(EEPROM_DATA,YYMM), 
 					(uchar*)&g_buf[20], 8, 1  ) ;
	    if ( (g_buf[2]==g_buf[22]) && 
	    		(g_buf[3]==g_buf[23]) &&
	    		(g_buf[4]==g_buf[24]) &&
	    		(g_buf[0]==g_buf[20]) && 
	    		(g_buf[1]==g_buf[21]) ) 
	    {
	    	
	    }
	    else
	    {
	   		g_buf[5] = g_buf[2];
	   		g_buf[6] = g_buf[3];
	   		g_buf[7] = g_buf[4];
	   		for ( i=8; i<15; i++ )
		   	{
		    	g_buf[i] = 0x00;
		    }			    
		    g_buf[15] = GetSum ( g_buf, 15 );
		    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,YYMM),
					(uchar*)g_buf,16 ) != 0 )
				return UPDATE_EEPROM_ERR;	
			
			g_dateLadder = 0x99; 	//不相等就进行切换 11  	
	    }
	     
    }
#endif

#ifdef TARIFF_ENABLE    
    //0x60 0x70处参数 时段表 11
//    if ( (updateFlag & BIT1) || 
//    	(g_buyPara.BuyCount==1) )
//    {
//	    //CardI2CRead ( CARD_ADDR, 0X60, (uchar*)g_buf, 16 );  
//	    pbuf = (uchar*)&g_commBuf[1].Data[0+0x20];    
//		Decrypt ( pbuf, 0x60, 16, DECRYPT_KEY );    
//	    if ( CheckDataFrame (pbuf) != 0 )
//	    {
//	    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
//	    }
//	    //高低位换位 11
//	    for ( i=0; i<4; i++ )
//	   	{
//	    	g_buf[3*i] = pbuf[3*i+3];	
//	    	g_buf[3*i+1] = pbuf[3*i+2];	
//	    	g_buf[3*i+2] = pbuf[3*i+1];	
//	    }
//	    	
//	    //CardI2CRead ( CARD_ADDR, 0X70, (uchar*)g_buf, 16 );  
//	    pbuf = (uchar*)&g_commBuf[1].Data[0+0x30];    
//		Decrypt ( pbuf, 0x70, 16, DECRYPT_KEY );    
//	    if ( CheckDataFrame (pbuf) != 0 )
//	    {
//	    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
//	    }
//	    //高低位换位 11
//	    for ( i=0; i<4; i++ )
//	    {
//	    	g_buf[12+3*i] = pbuf[3*i+3];	
//	    	g_buf[12+3*i+1] = pbuf[3*i+2];	
//	    	g_buf[12+3*i+2] = pbuf[3*i+1];	
//	    }	
//	    	
//	    //更新到EEPROM中 11
//	    //计算校验和 11	
//	    g_buf[24] = GetSum ( g_buf, 24 );
//	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,HHMMNN1),
//				(uchar*)g_buf,25 ) != 0 )
//			return UPDATE_EEPROM_ERR;	    
//    }
    
    //0x100~0x1F0 时段表 11
    if ( (updateFlag & BIT1) || 
    	(g_buyPara.BuyCount==1) )
    {
	    if ( ReadBlockData ( 0x10, (uchar*)g_buf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    }
	    
	    if ( ReadBlockData ( 0x11, (uchar*)&g_buf[16] ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    }
	       
		Decrypt ( g_buf, 0x00, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame (g_buf) != 0 )
	    {
	    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    }
	    //年时区个数 g_buf[1] 11
	    //年时区数判断 11
		if ( (g_buf[1] > 4)  )
		{
			return  CARD_NOT_CONSISTENT;		//非法卡 11			
		}					
	    //时段表数 g_buf[2] 11
	    if ( (g_buf[2] > 8)  )
		{
			return  CARD_NOT_CONSISTENT;		//非法卡 11		
		}
	    //时段数 g_buf[3] 11
	    g_buf[0] = ((g_buf[3]>>4)&0x0f)*10+g_buf[3]&0x0f;
		if ( (g_buf[0] > 14)  )
		{
			return  CARD_NOT_CONSISTENT;		//非法卡 11			
		}
	    g_buf[3] = g_buf[0];
	    g_buf[0] = g_buf[1];      	
		g_buf[1] = g_buf[2]; 
		g_buf[2] = g_buf[3]; 
		   
		Decrypt ( (uchar*)&g_buf[16], 0x10, 16, DECRYPT_KEY );    
	    if ( CheckDataFrame ((uchar*)&g_buf[16]) != 0 )
	    {
	    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
	    }	
	    //高低位换位 11
	    for ( i=0; i<4; i++ ) 
	   	{
	   		g_buf[3+3*i] = g_buf[19+3*i];			//NN
	   		g_buf[4+3*i] = g_buf[18+3*i];			//MM
	   		g_buf[5+3*i] = g_buf[17+3*i];			//YY
	   	}   	
	    //更新到EEPROM中 11
	    g_buf[15] = GetSum ( g_buf, 15 );
	    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,YearZoneNum),
				(uchar*)g_buf, 16 ) != 0 )
			return UPDATE_EEPROM_ERR;	
		
		//	
		cnt = g_buf[1];		
		for ( i=0; i<cnt; i++ )   
		{
			pbuf = (uchar*)&g_commBuf[0].Data[40];
			if ( ReadBlockData ( 0x14+4*i, (uchar*)pbuf ) == FALSE ) 
		    {
		    	return RF_READ_TYPE_ERR;	
		    } 
		    
		    if ( ReadBlockData ( 0x15+4*i, (uchar*)pbuf+16 ) == FALSE ) 
		    {
		    	return RF_READ_TYPE_ERR;	
		    }
		    
		    if ( ReadBlockData ( 0x16+4*i, (uchar*)pbuf+32 ) == FALSE ) 
		    {
		    	return RF_READ_TYPE_ERR;	
		    }
		       
			Decrypt ( pbuf, (uchar)(0x140+0x40*i), 16, DECRYPT_KEY );
			if ( CheckDataFrame (pbuf) != 0 )
		    {
		    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
		    }	
		    //高低位换位 11
		    for ( j=0; j<4; j++ ) 
		   	{
		   		g_buf[0+3*j] = pbuf[3+3*j];			//NN
		   		g_buf[1+3*j] = pbuf[2+3*j];			//MM
		   		g_buf[2+3*j] = pbuf[1+3*j];			//HH
		   	}   
		    
			pbuf += 16;
			Decrypt ( pbuf, (uchar)(0x150+0x40*i), 16, DECRYPT_KEY );
			if ( CheckDataFrame (pbuf) != 0 )
		    {
		    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
		    }			    
		    //高低位换位 11
		    for ( j=0; j<4; j++ ) 
		   	{
		   		g_buf[12+3*j] = pbuf[3+3*j];			//NN
		   		g_buf[13+3*j] = pbuf[2+3*j];			//MM
		   		g_buf[14+3*j] = pbuf[1+3*j];			//HH
		   	}   	
		    
		    pbuf += 16;
			Decrypt ( pbuf, (uchar)(0x160+0x40*i), 16, DECRYPT_KEY );
			if ( CheckDataFrame (pbuf) != 0 )
		    {
		    	return  CARD_NOT_CONSISTENT;		//非法卡 11	
		    }			    
		    //高低位换位 11
		    for ( j=0; j<4; j++ ) 
		   	{
		   		g_buf[24+3*j] = pbuf[3+3*j];			//NN
		   		g_buf[25+3*j] = pbuf[2+3*j];			//MM
		   		g_buf[26+3*j] = pbuf[1+3*j];			//HH
		   	}
		   	
		    for(j=36;j<42;j++)
		    	g_buf[j] = 0;
		    
		    //更新到EEPROM中 11
		    g_buf[42] = GetSum ( g_buf, 42 );
		    if ( StoreToE2ROMAndBackup ( offsetof(EEPROM_DATA,HHMMNN1)+48*(uint16)i,
					(uchar*)g_buf, 43 ) != 0 )
				return UPDATE_EEPROM_ERR;			    
		} 
    }
    
#endif
    
    return 0;   
}


/*
*****************************************************************************************
* fuction name: ProcessReadbackCard
*
* Description : this function process out super card initializing
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/

static uchar ProcessReadbackCard ( void )
{          
    uchar i,cnt;
    uchar *pbuf;
    uint32 temp32;
    uchar block;
    	
	block = 4;
	cnt = g_commBuf[0].Data[2];
	for ( i=0; i<cnt; i++ )
	{
		pbuf = (uchar*)&g_commBuf[0].Data[0+0x20];
		if ( ReadBlockData ( block, (uchar*)pbuf ) == FALSE ) 
	    {
	    	return RF_READ_TYPE_ERR;	
	    }	
	    if ( pbuf[0] != DECRYPT_KEY )
	    {
	    	break;	
	    }
	    
	    block += 4; 	    
	}
	        
    g_buf[0] = DECRYPT_KEY;
    //分区号 2     11
    g_buf[1] = (uchar)((g_addr.Zone>>8) & 0xff);
    g_buf[2] = (uchar)(g_addr.Zone & 0xff);
    
    //卡号 6 11
   	for ( i=0; i<6; i++ )
    	g_buf[3+i] = g_addr.CardNum[5-i];
        		       	    	
   	//表号 6 11
    for ( i=0; i<6; i++ )
    	g_buf[9+i] = g_addr.MeterAddr[5-i];
    //购电次数 2 11
    g_buf[15] = (uchar)((g_buyPara.BuyCount>>8) & 0xff);
    g_buf[16] = (uchar)(g_buyPara.BuyCount & 0xff);
    //最近1次购电量/购电金额 4 11
    temp32 = g_buyPara.BuyQuan*100;
    g_buf[17] = (uchar)((temp32>>24) & 0xff);
    g_buf[18] = (uchar)((temp32>>16) & 0xff);
    g_buf[19] = (uchar)((temp32>>8) & 0xff);
    g_buf[20] = (uchar)(temp32 & 0xff);
    //累计用电量	4  11
    g_buf[21] = (uchar)((g_energy.Accumulate>>24) & 0xff);
    g_buf[22] = (uchar)((g_energy.Accumulate>>16) & 0xff);
    g_buf[23] = (uchar)((g_energy.Accumulate>>8) & 0xff);
    g_buf[24] = (uchar)(g_energy.Accumulate & 0xff);
   	//透支电量/金额 4 11
   	g_buf[25] = (uchar)((g_energy.Overdraft>>24) & 0xff);
    g_buf[26] = (uchar)((g_energy.Overdraft>>16) & 0xff);
    g_buf[27] = (uchar)((g_energy.Overdraft>>8) & 0xff);
    g_buf[28] = (uchar)(g_energy.Overdraft & 0xff);
   	//当前剩余金额 4 11
   	g_buf[29] = (uchar)((g_energy.Balance>>24) & 0xff);
    g_buf[30] = (uchar)((g_energy.Balance>>16) & 0xff);
    g_buf[31] = (uchar)((g_energy.Balance>>8) & 0xff);
    g_buf[32] = (uchar)(g_energy.Balance & 0xff);
    //限电功率 added by Roger 2018/02/07 
    g_buf[33] = (uchar)((g_para.LimitPower>>8) & 0xff);
    g_buf[34] = (uchar)(g_para.LimitPower & 0xff);
    //最大囤积量 added by Roger 2018/02/07 
    g_buf[35] = (uchar)((g_para.MaximBalance>>8) & 0xff);
    g_buf[36] = (uchar)(g_para.MaximBalance & 0xff);
    //赊欠金额限值 added by Roger 2018/02/07 
    temp32 = g_para.CreditLimit/100;
    g_buf[37] = (uchar)((temp32>>8) & 0xff);
    g_buf[38] = (uchar)(temp32 & 0xff);
    //电表变比 added by Roger 2018/02/07 
    g_buf[39] = (uchar)((g_para.CurrentRatio>>8) & 0xff);
    g_buf[40] = (uchar)(g_para.CurrentRatio & 0xff);
    //电价	4  11
    temp32 = g_price;
    g_buf[41] = (uchar)((temp32>>24) & 0xff);
    g_buf[42] = (uchar)((temp32>>16) & 0xff);
    g_buf[43] = (uchar)((temp32>>8) & 0xff);
    g_buf[44] = (uchar)(temp32 & 0xff);
    
    g_buf[45] = GetSum ( g_buf, 45 );
       
    if ( WriteBlockData ( block, (uchar*)g_buf ) == FALSE ) 
    {
    	return RF_WRITE_CARD_ERR;	
    } 
    
    if ( WriteBlockData ( block+1, (uchar*)g_buf+16 ) == FALSE ) 
    {
    	return RF_WRITE_CARD_ERR;	
    }
    
    if ( WriteBlockData ( block+2, (uchar*)g_buf+32 ) == FALSE ) 
    {
    	return RF_WRITE_CARD_ERR;	
    }
                     
    return 0;   
}

//added by Roger 2015/07/24
/*
*****************************************************************************************
* fuction name: ProcessRetrunBack
*
* Description : this function process out super card initializing
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
static uchar ProcessRetrunBack ( void )
{
	uchar i;
	uint32 tempL;
		
	//先进行返写操作 11       
    g_buf[0] = 0xa6; 
    //剩余金额  11
    if ( g_energy.Overdraft > 0 )
    	tempL = g_energy.Overdraft+0x80000000;
    else
    	tempL = g_energy.Balance;	
    g_buf[1] = (uchar)((tempL>>24)&0xff);
    g_buf[2] = (uchar)((tempL>>16)&0xff);   
    g_buf[3] = (uchar)((tempL>>8)&0xff);
    g_buf[4] = (uchar)((tempL>>0)&0xff);
    //卡号 6 11
    for ( i=0; i<6; i++ )
		g_buf[5+i] = g_addr.CardNum[5-i];
    //电表状态 11
    g_buf[11] = g_errStatus.Byte;
    //购电次数 11
    g_buf[12] = (uchar)((g_buyPara.BuyCount>>8)&0xff);
    g_buf[13] = (uchar)((g_buyPara.BuyCount>>0)&0xff);
    
    g_buf[14] = 0; 
    for ( i=0; i<14; i++ )
        g_buf[14] += g_buf[i];
 	g_buf[15] = 0x3a; 
    Encrypt ( g_buf, 0, 16 ); 
      
	if ( WriteBlockData ( 4, (uchar*)&g_buf[0] ) == FALSE ) 
    {
    	return WRITE_BACK_ERR;	
    }
	    
	return 0;
}	

#ifdef BONUS_PADI_ENABLE
/*
*****************************************************************************************
* fuction name: ProcessBonusRetrunBack
*
* Description : this function process out super card initializing
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
static uchar ProcessBonusRetrunBack ( uint32 temp32, uint16 temp16 )
{
	uchar i;
		
	//先进行返写操作 11       
    g_buf[0] = 0xa6; 
    //剩余金额  11
    g_buf[1] = (uchar)((g_energy.Balance>>24)&0xff);
    g_buf[2] = (uchar)((g_energy.Balance>>16)&0xff);   
    g_buf[3] = (uchar)((g_energy.Balance>>8)&0xff);
    g_buf[4] = (uchar)((g_energy.Balance>>0)&0xff);
    //购电次数 11
    g_buf[5] = (uchar)((g_buyPara.BuyCount>>8)&0xff);
    g_buf[6] = (uchar)((g_buyPara.BuyCount>>0)&0xff);
    //补助剩余金额  11
    g_buf[7] = (uchar)((temp32>>24)&0xff);
    g_buf[8] = (uchar)((temp32>>16)&0xff);   
    g_buf[9] = (uchar)((temp32>>8)&0xff);
    g_buf[10] = (uchar)((temp32>>0)&0xff);
    //购电次数 11
    g_buf[11] = (uchar)((temp16>>8)&0xff);
    g_buf[12] = (uchar)((temp16>>0)&0xff);
    g_buf[13] = 0;
    g_buf[14] = 0; 
    for ( i=0; i<14; i++ )
        g_buf[14] += g_buf[i];
 	g_buf[15] = 0x3a; 
      	
	if ( WriteBlockData ( 4, (uchar*)&g_buf[0] ) == FALSE ) 
    {
    	return WRITE_BACK_ERR;	
    }
	    
	return 0;
}
#endif

/*
*****************************************************************************************
* fuction name: ReadBlockData
*
* Description : this function process IC card when detect IC card plug in
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
uchar ReadBlockData ( uchar block, uchar *pbuf )
{
	uint16 startAddr;
			
	//密码认证 11
    if ( CV520MFAuthent ( &RF_PASSWORD[(block>>2)*6], g_rfUID, block|0x03, 0x61 ) == FALSE )
    {
    	return FALSE;	
    }
    
    //读卡数据   11         
    if ( CV520ReadData ( block )== FALSE )
    {
    	return FALSE;		
    }
    
    startAddr = ((uint16)block)<<4;
    memcpy ( pbuf, (uchar*)&g_rfRevBuf[0], 16 );   
    	
	return TRUE;	
}

/*
*****************************************************************************************
* fuction name: ReadBlockData
*
* Description : this function process IC card when detect IC card plug in
*
* Arguments   : none
*		
* returns     : none
*
* Notes     :	 
******************************************************************************************
*/
uchar WriteBlockData ( uchar block, uchar *pbuf )
{

			
	//密码认证 11
    if ( CV520MFAuthent ( &RF_PASSWORD[(block>>2)*6], g_rfUID, block|0x03, 0x61 ) == FALSE )
    {
    	return FALSE;	
    }
      
    
    if ( CV520WriteData ( block, pbuf )== FALSE )
    	return FALSE;
    	
	return TRUE;	
}

#endif		